name: theBarcodeApi Application Deployment

on:
  workflow_run:
    workflows: ["theBarcodeApi Infrastructure Setup"]
    branches: [main]
    types:
      - completed
  workflow_dispatch:

env:
  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT }}
  SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  API_SECRET_KEY: ${{ secrets.API_SECRET_KEY }}
  API_MASTER_KEY: ${{ secrets.API_MASTER_KEY }}

jobs:
  frontend-deployment:
    runs-on: self-hosted
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    steps:
    - uses: actions/checkout@v3

    - name: Verify Working Directory
      run: |
        cd /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI
        if [ ! -f "package.json" ]; then
          echo "Error: package.json not found!"
          exit 1
        fi

    - name: Use Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run linter
      run: npm run lint

    - name: Build
      run: npm run build

    - name: Create frontend deployment script
      run: |
        cat << 'EOF' > deploy_frontend.sh
        #!/bin/bash
        set -e

        source /tmp/env_vars

        echo "Starting frontend deployment..."

        # Create directories
        mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases
        NEW_RELEASE="/opt/thebarcodeapi/${ENVIRONMENT}/releases/release-$(date +%Y%m%d%H%M%S)"
        echo "Creating new release directory: $NEW_RELEASE"
        mkdir -p "$NEW_RELEASE"

        # Copy Next.js build files
        echo "Copying build files to new release directory"
        cp -R /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI/.next "$NEW_RELEASE/"
        cp -R /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI/public "$NEW_RELEASE/"
        cp /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI/package.json "$NEW_RELEASE/"
        cp /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI/package-lock.json "$NEW_RELEASE/"

        # Change to the new release directory
        cd "$NEW_RELEASE"

        # Install production dependencies
        npm ci --only=production --omit=dev

        # Get the version from package.json
        VERSION=$(node -p "require('./package.json').version")

        # Update symlink
        echo "Creating symlink to new release"
        ln -sfn "$NEW_RELEASE" /opt/thebarcodeapi/${ENVIRONMENT}/current

        # Clean up old releases (keep last 5)
        echo "Cleaning up old releases"
        cd /opt/thebarcodeapi/${ENVIRONMENT}/releases && ls -1dt */ | tail -n +6 | xargs rm -rf

        echo "Starting/Restarting PM2 process with version $VERSION"
        if pm2 list | grep -q "thebarcodeapi-frontend-${ENVIRONMENT}"; then
          pm2 reload "thebarcodeapi-frontend-${ENVIRONMENT}" --update-env
        else
          pm2 start npm --name "thebarcodeapi-frontend-${ENVIRONMENT}" -- start
        fi

        # Update the process with the version
        pm2 set "thebarcodeapi-frontend-${ENVIRONMENT}:APP_VERSION" $VERSION

        # Save the new PM2 process list
        pm2 save

        # Set permissions
        echo "Changing ownership of /opt/thebarcodeapi"
        chown -R www-data:www-data /opt/thebarcodeapi

        echo "Frontend deployment completed"
        EOF
        chmod +x deploy_frontend.sh

    - name: Deploy Frontend
      run: |
        echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" > /tmp/env_vars
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./deploy_frontend.sh
        rm -f /tmp/env_vars

    - name: Verify Frontend Deployment
      run: |
        cat << 'EOF' > verify_frontend.sh
        #!/bin/bash
        set -e

        source /tmp/env_vars

        echo "Verifying frontend deployment..."
        echo "Checking current symlink:"
        ls -la /opt/thebarcodeapi/${ENVIRONMENT}/current

        echo "Checking Next.js application status:"
        pm2 list | grep thebarcodeapi-frontend-${ENVIRONMENT}

        echo "Testing frontend health..."
        curl -I http://localhost:3000 || echo "Frontend not responding"

        echo "Frontend verification completed"
        EOF
        chmod +x verify_frontend.sh

        echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" > /tmp/env_vars
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./verify_frontend.sh
        rm -f /tmp/env_vars

  backend-deployment:
    runs-on: self-hosted
    needs: frontend-deployment
    steps:
    - uses: actions/checkout@v3

    - name: Setup Initial Directories
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/barcodeAPI
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/data/postgres
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/data/redis
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/backups
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R www-data:www-data /opt/thebarcodeapi

    - name: Setup Docker permissions
      run: |
        # Add runner to docker group if not already added
        if ! groups | grep -q docker; then
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S usermod -aG docker $USER
          # Create a subshell with new group
          exec sg docker -c "docker ps"
        fi

    - name: Create env vars and docker vars
      run: |
        echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" > /tmp/env_vars
        echo "DB_PASSWORD=${{ env.DB_PASSWORD }}" >> /tmp/env_vars
        echo "POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}" >> /tmp/env_vars
        echo "API_SECRET_KEY=${{ env.API_SECRET_KEY }}" >> /tmp/env_vars
        echo "API_MASTER_KEY=${{ env.API_MASTER_KEY }}" >> /tmp/env_vars

        if $DOCKER_COMPOSE version &> /dev/null; then
          echo "DOCKER_COMPOSE='$DOCKER_COMPOSE'" > /tmp/docker_vars
        else
          echo "DOCKER_COMPOSE='docker-compose'" > /tmp/docker_vars
        fi

    - name: Create backend deployment script
      run: |

        source /tmp/env_vars

        cat << 'EOF' > deploy_backend.sh
        #!/bin/bash
        set -e

        source /tmp/env_vars
        source /tmp/docker_vars

        echo "Starting backend deployment..."
        echo "Using $DOCKER_COMPOSE command: $DOCKER_COMPOSE"

        # Navigate to backend directory
        cd /opt/thebarcodeapi/barcodeAPI

        # Create backup directory if it doesn't exist
        BACKUP_DIR="/opt/thebarcodeapi/backups/$(date +%Y%m%d_%H%M%S)"
        sudo mkdir -p $BACKUP_DIR
        sudo chown -R $USER:$USER $BACKUP_DIR

        # Function to safely backup PostgreSQL
        backup_postgres() {
            echo "Attempting PostgreSQL backup..."
            if $DOCKER_COMPOSE ps | grep -q "db"; then
                # Check if container is running and healthy
                if $DOCKER_COMPOSE exec db pg_isready -U postgres > /dev/null 2>&1; then
                    echo "PostgreSQL is ready, creating backup..."
                    # Create backup using postgres user inside container
                    $DOCKER_COMPOSE exec -T db bash -c 'pg_dumpall -U postgres > /tmp/backup.sql'
                    # Copy the backup file from container to host
                    $DOCKER_COMPOSE cp db:/tmp/backup.sql "$BACKUP_DIR/postgres_backup.sql"
                    # Clean up temporary file in container
                    $DOCKER_COMPOSE exec -T db rm /tmp/backup.sql
                    echo "PostgreSQL backup completed successfully"
                    return 0
                else
                    echo "PostgreSQL is not ready, skipping backup"
                    return 1
                fi
            else
                echo "PostgreSQL container not found, skipping backup"
                return 1
            fi
        }

        # Function to safely backup Redis
        backup_redis() {
            echo "Attempting Redis backup..."
            if $DOCKER_COMPOSE ps | grep -q "redis"; then
                if $DOCKER_COMPOSE exec -T redis redis-cli ping | grep -q "PONG"; then
                    echo "Redis is ready, creating backup..."
                    $DOCKER_COMPOSE exec -T redis redis-cli SAVE
                    $DOCKER_COMPOSE cp redis:/data/dump.rdb "$BACKUP_DIR/redis_dump.rdb"
                    echo "Redis backup completed successfully"
                    return 0
                else
                    echo "Redis is not ready, skipping backup"
                    return 1
                fi
            else
                echo "Redis container not found, skipping backup"
                return 1
            fi
        }

        # Perform backups
        backup_postgres || echo "Warning: PostgreSQL backup failed"
        backup_redis || echo "Warning: Redis backup failed"

        # Store current container states
        OLD_CONTAINERS=$($DOCKER_COMPOSE ps -q)

        # Stop current containers
        echo "Stopping current containers..."
        $DOCKER_COMPOSE down || true

        # Preserve existing data
        if [ -d "/opt/thebarcodeapi/data/postgres" ]; then
            echo "Preserving PostgreSQL data..."
            sudo cp -R /opt/thebarcodeapi/data/postgres "$BACKUP_DIR/postgres_data"
        fi

        if [ -d "/opt/thebarcodeapi/data/redis" ]; then
            echo "Preserving Redis data..."
            sudo cp -R /opt/thebarcodeapi/data/redis "$BACKUP_DIR/redis_data"
        fi

        # Ensure correct permissions on data directories
        echo "Setting up data directories and permissions..."
        sudo mkdir -p /opt/thebarcodeapi/data/postgres
        sudo mkdir -p /opt/thebarcodeapi/data/redis
        sudo chown -R 999:999 /opt/thebarcodeapi/data/postgres  # 999 is typical postgres user in container
        sudo chmod -R 700 /opt/thebarcodeapi/data/postgres
        sudo chown -R 999:999 /opt/thebarcodeapi/data/redis
        sudo chmod -R 755 /opt/thebarcodeapi/data/redis

        # Build and start new containers
        echo "Building and starting containers..."
        $DOCKER_COMPOSE build
        $DOCKER_COMPOSE up -d

        # Function to check container health
        check_container_health() {
            local container=$1
            local max_attempts=$2
            local attempt=1

            echo "Checking health of $container..."

            while [ $attempt -le $max_attempts ]; do
                if $DOCKER_COMPOSE ps $container | grep -q "healthy"; then
                    echo "$container is healthy"
                    return 0
                fi
                echo "Attempt $attempt/$max_attempts: $container not healthy yet, waiting..."

                # Print container logs for debugging
                echo "Recent logs for $container:"
                $DOCKER_COMPOSE logs --tail=50 $container

                sleep 10
                attempt=$((attempt + 1))
            done

            echo "$container failed to become healthy within timeout"
            return 1
        }

        # Function to perform rollback
        perform_rollback() {
            echo "Performing rollback..."

            $DOCKER_COMPOSE down

            # Restore data from backup with correct permissions
            if [ -d "$BACKUP_DIR/postgres_data" ]; then
                sudo rm -rf /opt/thebarcodeapi/data/postgres
                sudo cp -R "$BACKUP_DIR/postgres_data" /opt/thebarcodeapi/data/postgres
                sudo chown -R 999:999 /opt/thebarcodeapi/data/postgres
                sudo chmod -R 700 /opt/thebarcodeapi/data/postgres
            fi

            if [ -d "$BACKUP_DIR/redis_data" ]; then
                sudo rm -rf /opt/thebarcodeapi/data/redis
                sudo cp -R "$BACKUP_DIR/redis_data" /opt/thebarcodeapi/data/redis
                sudo chown -R 999:999 /opt/thebarcodeapi/data/redis
                sudo chmod -R 755 /opt/thebarcodeapi/data/redis
            fi

            if [ ! -z "$OLD_CONTAINERS" ]; then
                $DOCKER_COMPOSE up -d
            fi
        }

        # Check services health
        TIMEOUT=60

        for service in "db" "redis" "api"; do
            if ! check_container_health $service $TIMEOUT; then
                echo "$service failed health check. Rolling back..."
                perform_rollback
                exit 1
            fi
        done

        # Clean up old backups (keep last 5)
        find /opt/thebarcodeapi/backups -maxdepth 1 -type d -name "20*" | sort -r | tail -n +6 | xargs sudo rm -rf

        echo "Backend deployment completed successfully"
        EOF
        chmod +x deploy_backend.sh

    - name: Fix Docker permissions
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 666 /var/run/docker.sock

    - name: Setup DOCKER COMPOSE
      run: |
        # Check $DOCKER_COMPOSE installation
        if ! command -v docker-compose &> /dev/null && ! $DOCKER_COMPOSE version &> /dev/null; then
          echo "Installing $DOCKER_COMPOSE..."
          sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
          sudo chmod +x /usr/local/bin/docker-compose
          sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
        fi

        # Create env vars
        echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" > /tmp/env_vars
        echo "DB_PASSWORD=${{ env.DB_PASSWORD }}" >> /tmp/env_vars
        echo "POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}" >> /tmp/env_vars
        echo "API_SECRET_KEY=${{ env.API_SECRET_KEY }}" >> /tmp/env_vars
        echo "API_MASTER_KEY=${{ env.API_MASTER_KEY }}" >> /tmp/env_vars

        # Set $DOCKER_COMPOSE command
        if $DOCKER_COMPOSE version &> /dev/null; then
          echo "DOCKER_COMPOSE='$DOCKER_COMPOSE'" > /tmp/docker_vars
        else
          echo "DOCKER_COMPOSE='docker-compose'" > /tmp/docker_vars
        fi

    - name: CreateCopy Backend Files Script
      run: |
        # Copy backend files to the target directory
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp -R ./barcodeAPI/* /opt/thebarcodeapi/barcodeAPI/
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R www-data:www-data /opt/thebarcodeapi/barcodeAPI

    - name: Verify Working Directory
      run: |
        if [ ! -d "/opt/thebarcodeapi/barcodeAPI" ]; then
          echo "Error: /opt/thebarcodeapi/barcodeAPI directory not found!"
          exit 1
        fi

    # - name: Create backend deployment script
    #   run: |
    #     # Source the environment files we created earlier
    #     if [ ! -f "/tmp/env_vars" ] || [ ! -f "/tmp/docker_vars" ]; then
    #       echo "Error: Required environment files are missing"
    #       exit 1
    #     fi

    #     source /tmp/env_vars
    #     source /tmp/docker_vars

    #     cat << 'EOF' > deploy_backend.sh
    #     #!/bin/bash
    #     set -e

    #     source /tmp/env_vars
    #     source /tmp/docker_vars

    #     echo "Starting backend deployment..."
    #     echo "Using $DOCKER_COMPOSE command: $DOCKER_COMPOSE"

    #     # Navigate to backend directory
    #     cd /opt/thebarcodeapi/barcodeAPI

    #     # Create backup directory if it doesn't exist
    #     BACKUP_DIR="/opt/thebarcodeapi/backups/$(date +%Y%m%d_%H%M%S)"
    #     sudo mkdir -p $BACKUP_DIR

    #     # Function to check individual container health
    #     check_container_health() {
    #         local container=$1
    #         local max_attempts=$2
    #         local attempt=1

    #         echo "Checking health of $container..."

    #         while [ $attempt -le $max_attempts ]; do
    #             if $DOCKER_COMPOSE ps $container | grep -q "healthy"; then
    #                 echo "$container is healthy"
    #                 return 0
    #             fi
    #             echo "Attempt $attempt/$max_attempts: $container not healthy yet, waiting..."

    #             # Print container logs for debugging
    #             echo "Recent logs for $container:"
    #             $DOCKER_COMPOSE logs --tail=50 $container

    #             sleep 10
    #             attempt=$((attempt + 1))
    #         done

    #         echo "$container failed to become healthy within timeout"
    #         return 1
    #     }

    #     # Backup existing data
    #     if $DOCKER_COMPOSE ps 2>/dev/null | grep -q "db"; then
    #         echo "Backing up PostgreSQL data..."
    #         $DOCKER_COMPOSE exec -T db pg_dumpall -U postgres > "$BACKUP_DIR/postgres_backup.sql"
    #     fi

    #     if $DOCKER_COMPOSE ps | grep -q "redis"; then
    #         echo "Backing up Redis data..."
    #         $DOCKER_COMPOSE exec -T redis redis-cli SAVE
    #         $DOCKER_COMPOSE cp redis:/data/dump.rdb "$BACKUP_DIR/redis_dump.rdb"
    #     fi

    #     # Copy current backend files
    #     echo "Copying backend files..."
    #     cp -R /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI/barcodeAPI/* .

    #     # Store current container states
    #     OLD_CONTAINERS=$($DOCKER_COMPOSE ps -q)

    #     # Stop current containers
    #     echo "Stopping current containers..."
    #     $DOCKER_COMPOSE down || true

    #     # Preserve existing data
    #     if [ -d "/opt/thebarcodeapi/data/postgres" ]; then
    #         echo "Preserving PostgreSQL data..."
    #         cp -R /opt/thebarcodeapi/data/postgres "$BACKUP_DIR/postgres_data"
    #     fi

    #     if [ -d "/opt/thebarcodeapi/data/redis" ]; then
    #         echo "Preserving Redis data..."
    #         cp -R /opt/thebarcodeapi/data/redis "$BACKUP_DIR/redis_data"
    #     fi

    #     # Build and start new containers
    #     echo "Building and starting containers..."
    #     $DOCKER_COMPOSE build
    #     $DOCKER_COMPOSE up -d

    #     # Check health of each service independently
    #     echo "Checking service health..."
    #     TIMEOUT=60  # Timeout for each service (in attempts, 10 seconds each)

    #     # Check Redis first
    #     if ! check_container_health redis $TIMEOUT; then
    #         echo "Redis failed health check. Rolling back..."
    #         $DOCKER_COMPOSE down
    #         # Restore data and exit
    #         perform_rollback
    #         exit 1
    #     fi

    #     # Then check PostgreSQL
    #     if ! check_container_health db $TIMEOUT; then
    #         echo "PostgreSQL failed health check. Rolling back..."
    #         $DOCKER_COMPOSE down
    #         # Restore data and exit
    #         perform_rollback
    #         exit 1
    #     fi

    #     # Finally check API
    #     if ! check_container_health api $TIMEOUT; then
    #         echo "API failed health check. Rolling back..."
    #         $DOCKER_COMPOSE down
    #         # Restore data and exit
    #         perform_rollback
    #         exit 1
    #     fi

    #     # Function to perform rollback
    #     perform_rollback() {
    #         echo "Performing rollback..."

    #         # Restore data from backup
    #         if [ -d "$BACKUP_DIR/postgres_data" ]; then
    #             rm -rf /opt/thebarcodeapi/data/postgres
    #             cp -R "$BACKUP_DIR/postgres_data" /opt/thebarcodeapi/data/postgres
    #         fi

    #         if [ -d "$BACKUP_DIR/redis_data" ]; then
    #             rm -rf /opt/thebarcodeapi/data/redis
    #             cp -R "$BACKUP_DIR/redis_data" /opt/thebarcodeapi/data/redis
    #         fi

    #         # Start old containers if they existed
    #         if [ ! -z "$OLD_CONTAINERS" ]; then
    #             $DOCKER_COMPOSE up -d
    #         fi
    #     }

    #     # Verify database connectivity and restore data if needed
    #     echo "Verifying database connectivity..."
    #     if ! $DOCKER_COMPOSE exec -T db pg_isready -U barcodeboachiefamily -d barcode_api; then
    #         echo "Database connectivity failed. Restoring from backup..."
    #         if [ -f "$BACKUP_DIR/postgres_backup.sql" ]; then
    #             $DOCKER_COMPOSE exec -T db psql -U postgres < "$BACKUP_DIR/postgres_backup.sql"
    #         fi
    #     fi

    #     # Verify Redis connectivity
    #     echo "Verifying Redis connectivity..."
    #     if ! $DOCKER_COMPOSE exec -T redis redis-cli ping | grep -q "PONG"; then
    #         echo "Redis connectivity failed. Restoring from backup..."
    #         if [ -f "$BACKUP_DIR/redis_dump.rdb" ]; then
    #             $DOCKER_COMPOSE stop redis
    #             $DOCKER_COMPOSE cp "$BACKUP_DIR/redis_dump.rdb" redis:/data/dump.rdb
    #             $DOCKER_COMPOSE start redis
    #         fi
    #     fi

    #     # Final verification
    #     echo "Performing final verification..."
    #     if ! curl -f http://localhost:8000/health; then
    #         echo "Final health check failed. Rolling back..."
    #         perform_rollback
    #         exit 1
    #     fi

    #     # Clean up old backups (keep last 5)
    #     find /opt/thebarcodeapi/backups -maxdepth 1 -type d -name "20*" | sort -r | tail -n +6 | xargs rm -rf

    #     echo "Backend deployment completed successfully"

    #     EOF
    #     chmod +x deploy_backend.sh

    # - name: Copy Backend Files
    #   run: |
    #     # Copy backend files to the target directory
    #     echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp -R ./barcodeAPI/* /opt/thebarcodeapi/barcodeAPI/
    #     echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R www-data:www-data /opt/thebarcodeapi/barcodeAPI

    # - name: Verify Working Directory
    #   run: |
    #     if [ ! -d "/opt/thebarcodeapi/barcodeAPI" ]; then
    #       echo "Error: /opt/thebarcodeapi/barcodeAPI directory not found!"
    #       exit 1
    #     fi

    - name: Deploy Backend
      run: |
        if [ ! -f "/tmp/env_vars" ] || [ ! -f "/tmp/docker_vars" ]; then
          echo "Error: Required environment files are missing"
          exit 1
        fi

        set -x
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./deploy_backend.sh
        set +x

        rm -f /tmp/env_vars /tmp/docker_vars

    - name: Run Database Migrations
      run: |
        cd /opt/thebarcodeapi/barcodeAPI

        # Determine docker compose command
        if command -v docker-compose &> /dev/null; then
          COMPOSE_CMD="docker-compose"
        else
          COMPOSE_CMD="docker compose"
        fi

        echo "Using compose command: $COMPOSE_CMD"

        # Create temporary env file
        echo "Creating temporary environment file..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c 'cat << EOF > /opt/thebarcodeapi/barcodeAPI/.env
        DB_PASSWORD=${{ env.DB_PASSWORD }}
        POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}
        API_SECRET_KEY=${{ env.API_SECRET_KEY }}
        API_MASTER_KEY=${{ env.API_MASTER_KEY }}
        DATABASE_URL=postgresql+asyncpg://barcodeboachiefamily:${{ env.DB_PASSWORD }}@db/barcode_api
        REDIS_URL=redis://redis:6379
        ALGORITHM=HS256
        ACCESS_TOKEN_EXPIRE_MINUTES=30
        EOF'

        # Set proper permissions
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown www-data:www-data /opt/thebarcodeapi/barcodeAPI/.env
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 /opt/thebarcodeapi/barcodeAPI/.env

        # Run migrations
        echo "Running migrations..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD exec -T api alembic upgrade head

        # Check migration status
        MIGRATION_STATUS=$?
        if [ $MIGRATION_STATUS -eq 0 ]; then
          echo "Database migrations completed successfully"
        else
          echo "Migration failed! Checking logs..."
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs api
        fi

        # Cleanup
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /opt/thebarcodeapi/barcodeAPI/.env

        # Exit with migration status
        exit $MIGRATION_STATUS

    - name: Clean up
      if: always()
      run: |
        cd /opt/thebarcodeapi/barcodeAPI
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f .env
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker system prune -f --volumes

    - name: Verify Backend Deployment
      run: |
        cd /opt/thebarcodeapi/barcodeAPI

        # Create temporary env file for docker-compose
        cat << EOF > docker-compose.env
        DB_PASSWORD=${{ env.DB_PASSWORD }}
        POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}
        API_SECRET_KEY=${{ env.API_SECRET_KEY }}
        API_MASTER_KEY=${{ env.API_MASTER_KEY }}
        DATABASE_URL=postgresql+asyncpg://barcodeboachiefamily:${{ env.DB_PASSWORD }}@db/barcode_api
        EOF

        # Determine docker compose command
        if command -v docker-compose &> /dev/null; then
          COMPOSE_CMD="docker-compose"
        else
          COMPOSE_CMD="docker compose"
        fi

        echo "Verifying backend deployment..."

        echo "Checking Docker containers status:"
        $COMPOSE_CMD --env-file docker-compose.env ps

        echo "Checking container logs (last 10 lines):"
        $COMPOSE_CMD --env-file docker-compose.env logs --tail=10

        echo "Testing backend health:"
        MAX_RETRIES=3
        RETRY_COUNT=0
        until curl -f http://localhost:8000/health || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
          echo "Backend health check failed, retrying in 5 seconds..."
          sleep 5
          RETRY_COUNT=$((RETRY_COUNT + 1))
        done

        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
          echo "Backend health check failed after $MAX_RETRIES attempts"
          $COMPOSE_CMD --env-file docker-compose.env logs api
          exit 1
        fi

        echo "Backend verification completed successfully"

        # Cleanup
        rm -f docker-compose.env

    - name: Clean up
      if: always()
      run: |
        cd /opt/thebarcodeapi/barcodeAPI
        rm -f docker-compose.env
        docker system prune -f --volumes

  final-verification:
    runs-on: self-hosted
    needs: [frontend-deployment, backend-deployment]
    steps:
    - name: Verify Full Deployment
      run: |
        cat << 'EOF' > verify_full_deployment.sh
        #!/bin/bash
        set -e

        # Determine which compose command to use
        if command -v docker-compose &> /dev/null; then
          COMPOSE_CMD="docker-compose"
        else
          COMPOSE_CMD="docker compose"
        fi

        echo "Performing full deployment verification..."

        # Function to check endpoint health with retries
        check_endpoint() {
          local name=$1
          local url=$2
          local max_retries=3
          local retry_count=0
          local wait_time=5

          echo "Checking $name..."
          until curl -f "$url" || [ $retry_count -eq $max_retries ]; do
            echo "$name not responding, retrying in $wait_time seconds..."
            sleep $wait_time
            retry_count=$((retry_count + 1))
          done

          if [ $retry_count -eq $max_retries ]; then
            echo "$name health check failed after $max_retries attempts"
            return 1
          fi
          return 0
        }

        # Check frontend
        check_endpoint "frontend" "http://localhost:3000" || {
          echo "Frontend verification failed"
          pm2 logs thebarcodeapi-frontend-production --lines 50
          exit 1
        }

        # Check backend
        check_endpoint "backend" "http://localhost:8000/health" || {
          echo "Backend verification failed"
          $COMPOSE_CMD logs api --tail 50
          exit 1
        }

        echo "Checking PM2 processes:"
        pm2 list || {
          echo "Error: Failed to list PM2 processes"
          exit 1
        }

        echo "Checking Docker containers:"
        $COMPOSE_CMD -f /opt/thebarcodeapi/barcodeAPI/docker-compose.yml ps || {
          echo "Error: Failed to list Docker containers"
          exit 1
        }

        echo "Verifying Nginx configuration:"
        if ! nginx -t; then
          echo "Error: Nginx configuration test failed"
          exit 1
        fi

        # Verify Nginx is running
        if ! systemctl is-active --quiet nginx; then
          echo "Error: Nginx is not running"
          exit 1
        fi

        echo "Full deployment verification completed successfully"
        EOF
        chmod +x verify_full_deployment.sh

        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./verify_full_deployment.sh

    - name: Clean up build artifacts
      if: always()
      run: |
        rm -rf .next
        rm -rf build
        rm -f package.json package-lock.json
        rm -f verify_full_deployment.sh
        # Clean docker unused resources
        docker system prune -f --volumes

    - name: Notify on failure
      if: failure()
      run: |
        echo "============================================"
        echo "Deployment failed! Collecting diagnostic information..."
        echo "============================================"

        echo "PM2 Status:"
        pm2 list || true

        echo "Docker Container Status:"
        docker ps -a || true

        echo "Recent Docker Logs:"
        docker-compose -f /opt/thebarcodeapi/barcodeAPI/docker-compose.yml logs --tail=50 || true

        echo "Nginx Status:"
        systemctl status nginx || true

        echo "============================================"
        exit 1