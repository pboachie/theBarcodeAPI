name: theBarcodeApi Application Deployment

on:
  workflow_run:
    workflows: ["theBarcodeApi Infrastructure Setup"]
    branches: [main]
    types:
      - completed
  workflow_dispatch:

env:
  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT }}
  SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  API_SECRET_KEY: ${{ secrets.API_SECRET_KEY }}
  API_MASTER_KEY: ${{ secrets.API_MASTER_KEY }}

jobs:
  frontend-deployment:
    runs-on: self-hosted
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    steps:
      - uses: actions/checkout@v3

      - name: Verify Working Directory
        run: |
          pwd
          if [ ! -f "package.json" ]; then
            echo "Error: package.json not found!"
            exit 1
          fi

      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20.x'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linter
        run: npm run lint

      - name: Build
        run: npm run build

      - name: Deploy Frontend
        run: |
          echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" > /tmp/env_vars

          cat << 'EOF' > deploy_frontend.sh
          #!/bin/bash
          set -e

          source /tmp/env_vars

          echo "Starting frontend deployment..."

          # Create directories
          mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases
          NEW_RELEASE="/opt/thebarcodeapi/${ENVIRONMENT}/releases/release-$(date +%Y%m%d%H%M%S)"
          echo "Creating new release directory: $NEW_RELEASE"
          mkdir -p "$NEW_RELEASE"

          # Copy Next.js build files
          echo "Copying build files to new release directory"
          cp -R ./.next "$NEW_RELEASE/"
          cp -R ./public "$NEW_RELEASE/"
          cp ./package.json "$NEW_RELEASE/"
          cp ./package-lock.json "$NEW_RELEASE/"

          # Change to the new release directory
          cd "$NEW_RELEASE"

          # Install production dependencies
          npm ci --only=production --omit=dev

          # Get the version from package.json
          VERSION=$(node -p "require('./package.json').version")

          # Update symlink
          ln -sfn "$NEW_RELEASE" /opt/thebarcodeapi/${ENVIRONMENT}/current

          # Clean up old releases (keep last 5)
          cd /opt/thebarcodeapi/${ENVIRONMENT}/releases
          ls -1dt */ | tail -n +6 | xargs rm -rf

          echo "Starting/Restarting PM2 process with version $VERSION"
          if pm2 list | grep -q "thebarcodeapi-frontend-${ENVIRONMENT}"; then
            pm2 reload "thebarcodeapi-frontend-${ENVIRONMENT}" --update-env
          else
            pm2 start npm --name "thebarcodeapi-frontend-${ENVIRONMENT}" -- start
          fi

          # Update the process with the version
          pm2 set "thebarcodeapi-frontend-${ENVIRONMENT}:APP_VERSION" $VERSION

          # Save the new PM2 process list
          pm2 save

          # Set permissions
          chown -R www-data:www-data /opt/thebarcodeapi

          echo "Frontend deployment completed"
          EOF

          chmod +x deploy_frontend.sh
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./deploy_frontend.sh
          rm -f deploy_frontend.sh /tmp/env_vars

      - name: Verify Frontend Deployment
        run: |
          cat << 'EOF' > verify_frontend.sh
          #!/bin/bash
          set -e

          source /tmp/env_vars

          echo "Verifying frontend deployment..."
          echo "Checking current symlink:"
          ls -la /opt/thebarcodeapi/${ENVIRONMENT}/current

          echo "Checking Next.js application status:"
          pm2 list | grep thebarcodeapi-frontend-${ENVIRONMENT}

          echo "Testing frontend health..."
          curl -I http://localhost:3000 || echo "Frontend not responding"

          echo "Frontend verification completed"
          EOF

          chmod +x verify_frontend.sh
          echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" > /tmp/env_vars
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./verify_frontend.sh
          rm -f verify_frontend.sh /tmp/env_vars

  backend-deployment:
    runs-on: self-hosted
    needs: frontend-deployment
    steps:
      - uses: actions/checkout@v3

      - name: Setup Initial Directories
        run: |
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/barcodeAPI
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/data/{postgres,redis}
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/backups
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R www-data:www-data /opt/thebarcodeapi

      - name: Setup Docker
        run: |
          # Fix Docker permissions
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 666 /var/run/docker.sock

          # Add runner to docker group if not already added
          if ! groups | grep -q docker; then
            echo "${{ env.SUDO_PASSWORD }}" | sudo -S usermod -aG docker $USER
            # Create a subshell with new group
            exec sg docker -c "docker ps"
          fi

      - name: Setup Docker Compose
        run: |
          if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
            echo "Installing docker-compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            sudo ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose
          fi

          # Determine docker compose command
          if docker compose version &> /dev/null; then
            echo "DOCKER_COMPOSE='docker compose'" > /tmp/docker_vars
          else
            echo "DOCKER_COMPOSE='docker-compose'" > /tmp/docker_vars
          fi

      - name: Copy Backend Files
        run: |
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp -R ./barcodeAPI/* /opt/thebarcodeapi/barcodeAPI/
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R www-data:www-data /opt/thebarcodeapi/barcodeAPI

      - name: Create Environment Files
        run: |
          # Create backend .env file
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c 'cat << EOF > /opt/thebarcodeapi/barcodeAPI/.env
          DB_PASSWORD=${{ env.DB_PASSWORD }}
          POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}
          API_SECRET_KEY=${{ env.API_SECRET_KEY }}
          API_MASTER_KEY=${{ env.API_MASTER_KEY }}
          DATABASE_URL=postgresql+asyncpg://barcodeboachiefamily:${{ env.DB_PASSWORD }}@db/barcode_api
          REDIS_URL=redis://redis:6379
          ALGORITHM=HS256
          ACCESS_TOKEN_EXPIRE_MINUTES=30
          EOF'

          # Set proper permissions for .env
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown www-data:www-data /opt/thebarcodeapi/barcodeAPI/.env
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 /opt/thebarcodeapi/barcodeAPI/.env

      - name: Deploy Backend
        run: |
          cd /opt/thebarcodeapi/barcodeAPI
          source /tmp/docker_vars

          # Backup current state
          BACKUP_DIR="/opt/thebarcodeapi/backups/$(date +%Y%m%d_%H%M%S)"
          sudo mkdir -p "$BACKUP_DIR"

          if $DOCKER_COMPOSE ps 2>/dev/null | grep -q "db"; then
            if $DOCKER_COMPOSE exec db pg_isready -U postgres > /dev/null 2>&1; then
              $DOCKER_COMPOSE exec -T db pg_dumpall -U postgres > "$BACKUP_DIR/postgres_backup.sql"
            fi
          fi

          if $DOCKER_COMPOSE ps 2>/dev/null | grep -q "redis"; then
            if $DOCKER_COMPOSE exec -T redis redis-cli ping | grep -q "PONG"; then
              $DOCKER_COMPOSE exec -T redis redis-cli SAVE
              $DOCKER_COMPOSE cp redis:/data/dump.rdb "$BACKUP_DIR/redis_dump.rdb"
            fi
          fi

          # Stop current containers
          $DOCKER_COMPOSE down

          # Build and start new containers
          $DOCKER_COMPOSE build
          $DOCKER_COMPOSE up -d

          # Wait for services to be healthy
          for service in "db" "redis" "api"; do
            echo "Waiting for $service to be healthy..."
            attempts=0
            max_attempts=30
            until $DOCKER_COMPOSE ps $service | grep -q "healthy" || [ $attempts -eq $max_attempts ]; do
              echo "Attempt $((attempts+1))/$max_attempts: $service not healthy yet..."
              sleep 10
              attempts=$((attempts+1))
            done

            if [ $attempts -eq $max_attempts ]; then
              echo "$service failed to become healthy"
              exit 1
            fi
          done

      - name: Run Migrations
        run: |
          cd /opt/thebarcodeapi/barcodeAPI
          source /tmp/docker_vars

          echo "Running database migrations..."
          $DOCKER_COMPOSE exec -T api alembic upgrade head

      - name: Verify Backend Deployment
        run: |
          cd /opt/thebarcodeapi/barcodeAPI
          source /tmp/docker_vars

          echo "Verifying backend deployment..."

          echo "Checking container status:"
          $DOCKER_COMPOSE ps

          echo "Testing API health:"
          curl -f http://localhost:8000/health || {
            echo "API health check failed"
            $DOCKER_COMPOSE logs api
            exit 1
          }

  final-verification:
    runs-on: self-hosted
    needs: [frontend-deployment, backend-deployment]
    steps:
      - name: Verify Full Deployment
        run: |
          echo "Performing full deployment verification..."

          # Check frontend
          curl -f http://localhost:3000 || {
            echo "Frontend verification failed"
            pm2 logs thebarcodeapi-frontend-production --lines 50
            exit 1
          }

          # Check backend
          curl -f http://localhost:8000/health || {
            echo "Backend verification failed"
            docker compose logs api --tail 50
            exit 1
          }

          # Check services status
          echo "Checking PM2 processes:"
          pm2 list

          echo "Checking Docker containers:"
          docker compose ps

          echo "Verifying Nginx configuration:"
          sudo nginx -t

          echo "Checking Nginx service:"
          systemctl is-active --quiet nginx || {
            echo "Error: Nginx is not running"
            exit 1
          }

          echo "Full deployment verification completed successfully"

      - name: Clean up
        if: always()
        run: |
          # Clean up environment files
          sudo rm -f /opt/thebarcodeapi/barcodeAPI/.env
          rm -f /tmp/env_vars /tmp/docker_vars

          # Clean up Docker resources
          docker system prune -f --volumes