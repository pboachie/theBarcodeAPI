name: theBarcodeApi Application Deployment

on:
  workflow_run:
    workflows: ["theBarcodeApi Infrastructure Setup"]
    branches: [main]
    types:
      - completed
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy'
        required: false
        default: 'main'


env:
  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT }}
  SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  API_SECRET_KEY: ${{ secrets.API_SECRET_KEY }}
  API_MASTER_KEY: ${{ secrets.API_MASTER_KEY }}

jobs:
  frontend-deployment:
    runs-on: self-hosted
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    steps:
    - name: Determine branch
      id: get_branch
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "branch=${{ github.event.inputs.branch }}" >> $GITHUB_OUTPUT
        else
          echo "branch=main" >> $GITHUB_OUTPUT
        fi

    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Get all commits
        ref: ${{ github.ref }} # Checkout the specified branch

    - name: Check for frontend changes
      id: check_frontend_changes
      run: |
        # Debug information
        echo "Current directory: $(pwd)"
        echo "Event type: ${{ github.event_name }}"

        # Check if this is a first deployment
        if [ ! -d "/opt/thebarcodeapi/${ENVIRONMENT}/current" ]; then
          echo "First deployment detected"
          echo "changes=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # For manual triggers, we'll check the current deployment
          CURRENT_DIR="/opt/thebarcodeapi/${ENVIRONMENT}/current"

          if [ -f "${CURRENT_DIR}/.git-commit" ]; then
            DEPLOYED_COMMIT=$(cat "${CURRENT_DIR}/.git-commit")
            echo "Found deployed commit: ${DEPLOYED_COMMIT}"

            # Verify the commit exists in git history
            if git rev-parse --verify "${DEPLOYED_COMMIT}^{commit}" >/dev/null 2>&1; then
              echo "Comparing changes with deployed commit ${DEPLOYED_COMMIT}"
              CHANGES=$(git diff --name-only "${DEPLOYED_COMMIT}" HEAD -- 'src/' 'public/' 'package.json' 'package-lock.json' 'next.config.js' 'tailwind.config.js' || true)
            else
              echo "Deployed commit ${DEPLOYED_COMMIT} not found in history, forcing update"
              CHANGES="force_update"
            fi
          else
            echo "No .git-commit file found in current deployment, forcing update"
            CHANGES="force_update"
          fi
        else
          # For automated triggers, compare with previous commit
          echo "Comparing with previous commit"
          CHANGES=$(git diff --name-only HEAD^ HEAD -- 'src/' 'public/' 'package.json' 'package-lock.json' 'next.config.js' 'tailwind.config.js' || true)
        fi

        if [ ! -z "$CHANGES" ]; then
          echo "Frontend changes detected:"
          echo "$CHANGES"
          echo "changes=true" >> $GITHUB_OUTPUT
        else
          echo "No frontend changes detected"
          echo "changes=false" >> $GITHUB_OUTPUT
        fi

    - name: Store Git commit hash
      if: steps.check_frontend_changes.outputs.changes == 'true'
      run:  |
        git rev-parse HEAD > .git-commit

    - name: Validate Environment Variables
      run: |
        for var in ENVIRONMENT DB_PASSWORD POSTGRES_PASSWORD API_SECRET_KEY API_MASTER_KEY; do
          if [ -z "${!var}" ]; then
            echo "Error: $var is not set"
            exit 1
          fi
        done

    - name: Verify Working Directory
      run: |
        cd /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI
        if [ ! -f "package.json" ]; then
          echo "Error: package.json not found!"
          exit 1
        fi

    - name: Use Node.js
      if: steps.check_frontend_changes.outputs.changes == 'true'
      uses: actions/setup-node@v3
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Cache Next.js build
      if: steps.check_frontend_changes.outputs.changes == 'true'
      uses: actions/cache@v3
      with:
        path: |
          .next/cache
        key: ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}
        restore-keys: |
          ${{ runner.os }}-nextjs-${{ hashFiles('**/package-lock.json') }}-
          ${{ runner.os }}-nextjs-

    - name: Install dependencies
      if: steps.check_frontend_changes.outputs.changes == 'true'
      run: npm ci

    - name: Run linter
      if: steps.check_frontend_changes.outputs.changes == 'true'
      run: npm run lint

    - name: Build
      if: steps.check_frontend_changes.outputs.changes == 'true'
      run: npm run build

    - name: Deploy Frontend
      run: |
        # Create env vars file
        cat > .env_vars << EOF
        ENVIRONMENT=${{ env.ENVIRONMENT }}
        NODE_ENV=production
        SUDO_PASSWORD=${{ env.SUDO_PASSWORD }}
        CHANGES=${{ steps.check_frontend_changes.outputs.changes }}
        EOF

        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 600 .env_vars

        # Create deployment script
        cat > deploy_frontend.sh << 'EOF'
        #!/bin/bash
        set -e

        if [ ! -f ".env_vars" ]; then
            echo "Error: .env_vars not found"
            exit 1
        fi

        source .env_vars

        echo "Starting frontend deployment..."

        if [ "$CHANGES" == "false" ]; then
          echo "No changes detected in frontend files. Restarting PM2 process only..."

          # Restart PM2 with zero downtime
          pm2 list | grep "thebarcodeapi-frontend-${ENVIRONMENT}" | awk '{print $2}' | while read process; do
              echo "Reloading process: $process"
              PM2_HOME="/home/github-runner/.pm2" pm2 reload "$process" --update-env
          done

          exit 0
        fi


        # Create base directories first
        echo "$SUDO_PASSWORD" | sudo -S mkdir -p /opt/thebarcodeapi
        echo "$SUDO_PASSWORD" | sudo -S mkdir -p "/opt/thebarcodeapi/${ENVIRONMENT}"
        echo "$SUDO_PASSWORD" | sudo -S mkdir -p "/opt/thebarcodeapi/${ENVIRONMENT}/releases"

        # Set initial permissions
        echo "$SUDO_PASSWORD" | sudo -S chown -R github-runner:github-runner /opt/thebarcodeapi

        # Create new release directory with timestamp
        TIMESTAMP=$(date +%Y%m%d%H%M%S)
        NEW_RELEASE="/opt/thebarcodeapi/${ENVIRONMENT}/releases/release-${TIMESTAMP}"
        CURRENT_DIR="/opt/thebarcodeapi/${ENVIRONMENT}/current"
        PREVIOUS_RELEASE_LINK="/opt/thebarcodeapi/${ENVIRONMENT}/previous"

        echo "Creating new release directory: $NEW_RELEASE"
        echo "$SUDO_PASSWORD" | sudo -S mkdir -p "$NEW_RELEASE"
        echo "$SUDO_PASSWORD" | sudo -S chown -R github-runner:github-runner "$NEW_RELEASE"

        # Copy build files to new release
        echo "Copying build files to new release directory"
        echo "$SUDO_PASSWORD" | sudo -S cp -R ./.next "$NEW_RELEASE/"
        echo "$SUDO_PASSWORD" | sudo -S cp -R ./public "$NEW_RELEASE/"
        echo "$SUDO_PASSWORD" | sudo -S cp ./package.json "$NEW_RELEASE/"
        echo "$SUDO_PASSWORD" | sudo -S cp ./package-lock.json "$NEW_RELEASE/"

        # Install dependencies in new release
        cd "$NEW_RELEASE"
        npm ci --omit=dev

        # Keep track of current release before switching
        if [ -L "$CURRENT_DIR" ]; then
            CURRENT_RELEASE=$(readlink -f "$CURRENT_DIR")
            echo "$SUDO_PASSWORD" | sudo -S ln -sfn "$CURRENT_RELEASE" "$PREVIOUS_RELEASE_LINK"
        fi

        # Atomic symlink swap
        echo "Creating symlink to new release"
        echo "$SUDO_PASSWORD" | sudo -S ln -sfn "$NEW_RELEASE" "$CURRENT_DIR.new"
        echo "$SUDO_PASSWORD" | sudo -S mv -Tf "$CURRENT_DIR.new" "$CURRENT_DIR"

        # Verify symlink
        if [ ! -L "$CURRENT_DIR" ] || [ ! -d "$(readlink -f "$CURRENT_DIR")" ]; then
            echo "Error: Failed to create symlink correctly"
            if [ -L "$PREVIOUS_RELEASE_LINK" ]; then
                echo "Rolling back to previous release..."
                echo "$SUDO_PASSWORD" | sudo -S ln -sfn "$(readlink -f "$PREVIOUS_RELEASE_LINK")" "$CURRENT_DIR"
                exit 1
            fi
        fi

        # Restart PM2 with zero downtime
        echo "Restarting PM2 process..."
        pm2 list | grep "thebarcodeapi-frontend-${ENVIRONMENT}" | awk '{print $2}' | while read process; do
            echo "Reloading process: $process"
            PM2_HOME="/home/github-runner/.pm2" pm2 reload "$process" --update-env || {
                echo "Failed to reload PM2 process, rolling back..."
                if [ -L "$PREVIOUS_RELEASE_LINK" ]; then
                    echo "$SUDO_PASSWORD" | sudo -S ln -sfn "$(readlink -f "$PREVIOUS_RELEASE_LINK")" "$CURRENT_DIR"
                    PM2_HOME="/home/github-runner/.pm2" pm2 reload "$process" --update-env
                fi
                exit 1
            }
        done

        # Clean up old releases (keep last 5)
        echo "Cleaning up old releases"
        cd "/opt/thebarcodeapi/${ENVIRONMENT}/releases"
        OLD_RELEASES=$(ls -1dt */ | tail -n +6)
        if [ ! -z "$OLD_RELEASES" ]; then
            echo "$SUDO_PASSWORD" | sudo -S rm -rf $OLD_RELEASES
        fi

        cd "$CURRENT_DIR"

        # Set final permissions
        echo "$SUDO_PASSWORD" | sudo -S chown -R www-data:www-data "/opt/thebarcodeapi/${ENVIRONMENT}/current"
        echo "$SUDO_PASSWORD" | sudo -S chmod -R 755 "/opt/thebarcodeapi/${ENVIRONMENT}/current"

        echo "Frontend deployment completed"
        EOF

        # Modify the deploy_frontend.sh script to include copying .git-commit
        sed -i '/echo "$SUDO_PASSWORD" | sudo -S cp .\/package-lock.json "$NEW_RELEASE\/"/a\
        if [ -f ".git-commit" ]; then\
            echo "$SUDO_PASSWORD" | sudo -S cp ./.git-commit "$NEW_RELEASE/"\
        fi' deploy_frontend.sh

        # Make the script executable
        chmod +x deploy_frontend.sh

        # Run the deployment script
        ./deploy_frontend.sh

        # Cleanup
        rm -f .env_vars

    - name: Verify Frontend Deployment
      run: |
        cat << 'EOF' > verify_frontend.sh
        #!/bin/bash
        # verify_frontend.sh
        set -e

        if [ ! -f "/tmp/env_vars" ]; then
            echo "Error: /tmp/env_vars not found"
            exit 1
        fi

        source /tmp/env_vars

        echo "Verifying frontend deployment..."

        # Check current symlink
        echo "Checking current symlink:"
        ls -la "/opt/thebarcodeapi/${ENVIRONMENT}/current"

        # PM2 Process Management
        echo "Managing PM2 process..."

        # Function to safely stop and delete PM2 processes
        cleanup_pm2() {
            local app_name="$1"
            echo "Cleaning up PM2 processes for $app_name..."

            # Stop all instances
            PM2_HOME="/home/github-runner/.pm2" pm2 stop "$app_name" || true
            sleep 5

            # Delete all instances
            PM2_HOME="/home/github-runner/.pm2" pm2 delete "$app_name" || true
            sleep 5

            # Flush PM2 logs
            PM2_HOME="/home/github-runner/.pm2" pm2 flush

            # Save PM2 state
            PM2_HOME="/home/github-runner/.pm2" pm2 save --force || true
        }

        # Clean up existing processes
        cleanup_pm2 "thebarcodeapi-frontend-${ENVIRONMENT}"

        # Wait for cleanup to complete
        sleep 5

        # Function to start PM2 with better error handling
        start_pm2_process() {
            echo "Starting Next.js application with PM2..."
            cd "/opt/thebarcodeapi/${ENVIRONMENT}/current" || exit 1

            # Start PM2
            PM2_HOME="/home/github-runner/.pm2" pm2 start "/opt/thebarcodeapi/${ENVIRONMENT}/ecosystem.config.js" \
                || {
                    echo "Failed to start PM2 process"
                    pm2 logs "thebarcodeapi-frontend-${ENVIRONMENT}" --lines 50
                    exit 1
                }

            local max_wait=60
            local count=0
            while [ $count -lt $max_wait ]; do
                # Get process status
                local status=$(PM2_HOME="/home/github-runner/.pm2" pm2 jlist | grep -o '"status":"[^"]*"' | head -1)

                if [[ $status == *"online"* ]]; then
                    echo "PM2 process is online"
                    # Additional verification - check if the app is responding
                    if curl -s -f "http://localhost:3000/" > /dev/null; then
                        echo "Application is responding"
                        PM2_HOME="/home/github-runner/.pm2" pm2 save --force
                        return 0
                    fi
                fi

                # Show process details every 10 seconds
                if [ $((count % 10)) -eq 0 ]; then
                    echo "Current PM2 status:"
                    PM2_HOME="/home/github-runner/.pm2" pm2 list
                    echo "Recent logs:"
                    PM2_HOME="/home/github-runner/.pm2" pm2 logs "thebarcodeapi-frontend-${ENVIRONMENT}" --lines 10 --nostream
                fi

                echo "Waiting for application to be ready... ($count/$max_wait)"
                sleep 1
                count=$((count + 1))
            done

            echo "Process verification failed. Showing logs:"
            PM2_HOME="/home/github-runner/.pm2" pm2 logs "thebarcodeapi-frontend-${ENVIRONMENT}" --lines 50
            return 1
        }

        # Main execution
        echo "Starting PM2 process..."
        if ! start_pm2_process; then
            echo "Failed to start PM2 process"
            exit 1
        fi

        # Save PM2 configuration
        PM2_HOME="/home/github-runner/.pm2" pm2 save --force || true

        check_frontend_health() {
            local max_attempts=12
            local attempt=1
            local timeout=5

            while [ $attempt -le $max_attempts ]; do
                echo "Health check attempt $attempt of $max_attempts..."

                # # Comprehensive status check
                # local pm2_status=$(PM2_HOME="/home/github-runner/.pm2" pm2 jlist)
                # if ! echo "$pm2_status" | grep -q '"status":"online".*"name":"thebarcodeapi-frontend-'; then
                #     echo "PM2 process is not running properly!"
                #     PM2_HOME="/home/github-runner/.pm2" pm2 list
                #     PM2_HOME="/home/github-runner/.pm2" pm2 logs "thebarcodeapi-frontend-${ENVIRONMENT}" --lines 50
                #     return 1
                # fi

                # Test the application endpoint with increased timeout
                if curl -s -f -m $timeout "http://localhost:3000/" > /dev/null; then
                    echo "Frontend is responding successfully!"
                    return 0
                fi

                echo "Frontend not ready yet, waiting 5 seconds... (Attempt $attempt/$max_attempts)"
                sleep 5
                attempt=$((attempt + 1))
            done

            echo "ERROR: Frontend failed to respond after health checks"
            echo "PM2 Status:"
            PM2_HOME="/home/github-runner/.pm2" pm2 list
            echo "Recent PM2 logs:"
            PM2_HOME="/home/github-runner/.pm2" pm2 logs "thebarcodeapi-frontend-${ENVIRONMENT}" --lines 50
            return 1
        }

        echo "Testing frontend health..."
        if ! check_frontend_health; then
            echo "DEPLOYMENT VERIFICATION FAILED"
            exit 1
        fi

        echo "Frontend verification completed successfully"
        EOF
        chmod +x verify_frontend.sh

        echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" | sudo tee /tmp/env_vars > /dev/null
        ./verify_frontend.sh
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /tmp/env_vars

  backend-deployment:
    runs-on: self-hosted
    needs: frontend-deployment
    steps:
    - name: Determine branch
      id: get_branch
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "branch=${{ github.event.inputs.branch }}" >> $GITHUB_OUTPUT
        else
          echo "branch=main" >> $GITHUB_OUTPUT
        fi

    - uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Get all commits
        ref: ${{ steps.get_branch.outputs.branch }}

    - name: Check for backend changes
      id: check_backend_changes
      run: |
        # Debug information
        echo "Current directory: $(pwd)"
        echo "Event type: ${{ github.event_name }}"
        echo "Git branch: $(git rev-parse --abbrev-ref HEAD)"

        # Check if this is a first deployment
        if [ ! -d "/opt/thebarcodeapi/${ENVIRONMENT}/releases/data" ]; then
          echo "First deployment detected"
          echo "changes=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # For manual triggers, we'll check the current deployment
          if [ -f "/opt/thebarcodeapi/barcodeAPI/.git-commit" ]; then
            DEPLOYED_COMMIT=$(cat "/opt/thebarcodeapi/barcodeAPI/.git-commit")
            echo "Found deployed commit: ${DEPLOYED_COMMIT}"

            # Verify the commit exists in git history
            if git rev-parse --verify "${DEPLOYED_COMMIT}^{commit}" >/dev/null 2>&1; then
              echo "Comparing changes with deployed commit ${DEPLOYED_COMMIT}"
              CHANGES=$(git diff --name-only "${DEPLOYED_COMMIT}" HEAD -- \
                'api/' \
                'alembic/' \
                'requirements.txt' \
                'Dockerfile' \
                '*.yml' \
                '*.ini' \
                'scripts/' \
                '*.sh' \
                || true)
            else
              echo "Deployed commit ${DEPLOYED_COMMIT} not found in history, forcing update"
              CHANGES="force_update"
            fi
          else
            echo "No .git-commit file found in current deployment, forcing update"
            CHANGES="force_update"
          fi
        else
          # For automated triggers, compare with previous commit
          echo "Comparing with previous commit"
          CHANGES=$(git diff --name-only HEAD^ HEAD -- \
            'api/' \
            'alembic/' \
            'requirements.txt' \
            'Dockerfile' \
            '*.yml' \
            '*.ini' \
            'scripts/' \
            '*.sh' \
            || true)
        fi

        if [ ! -z "$CHANGES" ]; then
          echo "Backend changes detected:"
          echo "$CHANGES"
          echo "changes=true" >> $GITHUB_OUTPUT
        else
          echo "No backend changes detected"
          echo "changes=false" >> $GITHUB_OUTPUT
        fi

        # Debug output
        echo "Git diff output:"
        git diff --name-only HEAD^ HEAD || true

    - name: Create .env file for backend
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c 'cat > /opt/thebarcodeapi/barcodeAPI/.env << EOF
        DB_PASSWORD=${{ env.DB_PASSWORD }}
        POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}
        SECRET_KEY=${{ env.API_SECRET_KEY }}
        MASTER_API_KEY=${{ env.API_MASTER_KEY }}
        API_VERSION=${{ vars.API_VERSION }}
        DATABASE_URL=postgresql+asyncpg://barcodeboachiefamily:${{ env.DB_PASSWORD }}@db/barcode_api
        REDIS_URL=redis://redis:6379
        ALGORITHM=HS256
        ACCESS_TOKEN_EXPIRE_MINUTES=30
        EOF'

        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown www-data:www-data /opt/thebarcodeapi/barcodeAPI/.env
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 /opt/thebarcodeapi/barcodeAPI/.env

        # Verify .env file was created and has content
        echo "Verifying .env file:"
        if [ -f "/opt/thebarcodeapi/barcodeAPI/.env" ]; then
          echo "File exists"
          echo "File permissions:"
          ls -l /opt/thebarcodeapi/barcodeAPI/.env
          echo "File contents:"
          cat /opt/thebarcodeapi/barcodeAPI/.env
        else
          echo "ERROR: .env file not created!"
          exit 1
        fi
        
    - name: Set up Docker Buildx
      if: steps.check_backend_changes.outputs.changes == 'true'
      uses: docker/setup-buildx-action@v3
      with:
        install: true

    - name: Cache Docker layers
      if: steps.check_backend_changes.outputs.changes == 'true'
      uses: actions/cache@v3
      with:
        path: |
          /opt/thebarcodeapi/barcodeAPI/.buildx-cache
          ~/.docker/buildx
        key: ${{ runner.os }}-buildx-${{ hashFiles('api/**', 'Dockerfile', 'requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-buildx-

    - name: Build and cache Docker image
      if: steps.check_backend_changes.outputs.changes == 'true'
      uses: docker/build-push-action@v5
      with:
        context: /opt/thebarcodeapi/barcodeAPI
        file: /opt/thebarcodeapi/barcodeAPI/Dockerfile
        push: false
        load: true
        tags: barcodeapi:latest
        cache-from: type=local,src=/opt/thebarcodeapi/barcodeAPI/.buildx-cache
        cache-to: type=local,dest=/opt/thebarcodeapi/barcodeAPI/.buildx-cache-new,mode=max
        build-args: |
          DEBIAN_FRONTEND=noninteractive
          PYTHON_ENV=production

    - name: Move cache
      if: steps.check_backend_changes.outputs.changes == 'true'
      run: |
        rm -rf /opt/thebarcodeapi/barcodeAPI/.buildx-cache
        mv /opt/thebarcodeapi/barcodeAPI/.buildx-cache-new /opt/thebarcodeapi/barcodeAPI/.buildx-cache

    - name: Store Git commit hash
      if: steps.check_backend_changes.outputs.changes == 'true'
      run: |
        git rev-parse HEAD > .git-commit
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp .git-commit /opt/thebarcodeapi/barcodeAPI/

    - name: Setup Initial Directories
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/barcodeAPI
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/backups/
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R github-runner:github-runner /opt/thebarcodeapi/barcodeAPI

    - name: Setup Docker and Environment
      run: |
        # Fix docker socket permissions
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 666 /var/run/docker.sock

        # Add runner to docker group if not already added
        if ! groups | grep -q docker; then
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S usermod -aG docker $USER
          # Reload groups without logging out
          exec sg docker newgrp docker
        fi

        # Create env_vars file
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c "cat > /tmp/env_vars << 'EOF'
        ENVIRONMENT=production
        DB_PASSWORD=${{ env.DB_PASSWORD }}
        POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}
        API_SECRET_KEY=${{ env.API_SECRET_KEY }}
        API_MASTER_KEY=${{ env.API_MASTER_KEY }}
        API_VERSION=${{ vars.API_VERSION }}
        EOF"

        # Determine and set docker compose command
        if command -v docker-compose &> /dev/null; then
            echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c 'echo "DOCKER_COMPOSE=docker-compose" > /tmp/docker_vars'
        elif command -v docker &> /dev/null && docker compose version &> /dev/null; then
            echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c 'echo "DOCKER_COMPOSE=docker compose" > /tmp/docker_vars'
        else
            echo "Neither docker-compose nor docker compose found!"
            exit 1
        fi

        # Debug output
        echo "Environment file contents:"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S cat /tmp/env_vars
        echo "Docker compose file contents:"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S cat /tmp/docker_vars

        # Verify Docker access
        docker ps

    - name: Create and run backend deployment script
      env:
        CHANGES: ${{ steps.check_backend_changes.outputs.changes }}
      run: |
        # Create deployment script
        cat > deploy_backend.sh << 'EOF'
        #!/bin/bash
        set -e

        # Source environment variables
        if [ ! -f "/tmp/env_vars" ]; then
            echo "Error: /tmp/env_vars not found"
            exit 1
        fi
        source /tmp/env_vars

        # Source docker compose command
        if [ ! -f "/tmp/docker_vars" ]; then
            echo "Error: /tmp/docker_vars not found"
            exit 1
        fi
        source /tmp/docker_vars

        cd /opt/thebarcodeapi/barcodeAPI

        # # Create temporary env file
        # echo "Creating temporary environment file..."
        # echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c 'cat << EOF > /opt/thebarcodeapi/barcodeAPI/.env
        # DB_PASSWORD=${DB_PASSWORD}
        # POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
        # SECRET_KEY=${API_SECRET_KEY}
        # MASTER_API_KEY=${API_MASTER_KEY}
        # API_VERSION=${API_VERSION:-v1}
        # DATABASE_URL=postgresql+asyncpg://barcodeboachiefamily:${DB_PASSWORD}@db/barcode_api
        # REDIS_URL=redis://redis:6379
        # ALGORITHM=HS256
        # ACCESS_TOKEN_EXPIRE_MINUTES=30
        # EOF'

        echo "Starting backend deployment..."
        echo "Using DOCKER_COMPOSE command: ${DOCKER_COMPOSE}"

        # If no changes detected, just check health and exit
        if [ "$CHANGES" == "false" ]; then
          echo "No changes detected in backend files. Verifying health only..."

          # Check if services are running
          if ! $DOCKER_COMPOSE ps | grep -q "Up"; then
            echo "Services are not running, starting them..."
            $DOCKER_COMPOSE up -d
          fi

          # Verify health
          for service in "db" "redis" "api"; do
            timeout 300 bash -c "until $DOCKER_COMPOSE ps $service 2>/dev/null | grep -q 'healthy'; do
              echo 'Waiting for $service to become healthy...'
              sleep 5
            done"
          done

          echo "Backend health verified"
          exit 0
        fi

        # Create backup directory
        BACKUP_DIR="/opt/thebarcodeapi/backups/${ENVIRONMENT:-production}/$(date +%Y%m%d_%H%M%S)"
        echo "$SUDO_PASSWORD" | sudo -S mkdir -p "${BACKUP_DIR}"
        echo "$SUDO_PASSWORD" | sudo -S chown -R $USER:$USER "${BACKUP_DIR}"

        # Function to safely backup PostgreSQL
        backup_postgres() {
            echo "Attempting PostgreSQL backup..."
            if $DOCKER_COMPOSE ps 2>/dev/null | grep -q "db"; then
                if $DOCKER_COMPOSE exec -T db pg_isready -U postgres > /dev/null 2>&1; then
                    echo "PostgreSQL is ready, creating backup..."
                    $DOCKER_COMPOSE exec -T db pg_dumpall -U postgres > "${BACKUP_DIR}/postgres_backup.sql" || {
                        echo "Failed to create backup"
                        return 1
                    }
                    echo "PostgreSQL backup completed successfully"
                    return 0
                fi
            fi
            echo "No existing PostgreSQL container or not ready, skipping backup"
            return 0
        }

        # Function to safely backup Redis
        backup_redis() {
            echo "Attempting Redis backup..."
            if $DOCKER_COMPOSE ps 2>/dev/null | grep -q "redis"; then
                if $DOCKER_COMPOSE exec -T redis redis-cli ping | grep -q "PONG"; then
                    echo "Redis is ready, creating backup..."
                    $DOCKER_COMPOSE exec -T redis redis-cli SAVE || {
                        echo "Failed to save Redis dump"
                        return 1
                    }

                    REDIS_ID=$($DOCKER_COMPOSE ps -q redis)
                    if [ ! -z "$REDIS_ID" ]; then
                        docker cp "${REDIS_ID}:/data/dump.rdb" "${BACKUP_DIR}/redis_dump.rdb" || {
                            echo "Failed to copy Redis dump"
                            return 1
                        }
                    else
                        echo "Could not find Redis container"
                        return 1
                    fi

                    echo "Redis backup completed successfully"
                    return 0
                fi
            fi
            echo "No existing Redis container or not ready, skipping backup"
            return 0
        }

        # Perform backups
        echo "Checking for existing containers to backup..."
        backup_postgres || echo "Note: PostgreSQL backup skipped"
        backup_redis || echo "Note: Redis backup skipped"

        # Store current container IDs
        OLD_CONTAINERS=$($DOCKER_COMPOSE ps -q 2>/dev/null || echo "")

        # Stop current containers
        echo "Stopping current containers..."
        $DOCKER_COMPOSE down || true

        # Preserve existing data
        if [ -d "/opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres" ]; then
            echo "Preserving PostgreSQL data..."
            echo "$SUDO_PASSWORD" | sudo -S cp -R /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres "${BACKUP_DIR}/postgres_data"
        fi

        if [ -d "/opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis" ]; then
            echo "Preserving Redis data..."
            echo "$SUDO_PASSWORD" | sudo -S cp -R /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis "${BACKUP_DIR}/redis_data"
        fi

        # Set up data directories
        echo "Setting up data directories..."
        echo "$SUDO_PASSWORD" | sudo -S mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres
        echo "$SUDO_PASSWORD" | sudo -S mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis
        echo "$SUDO_PASSWORD" | sudo -S chown -R 999:999 /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres
        echo "$SUDO_PASSWORD" | sudo -S chmod -R 700 /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres
        echo "$SUDO_PASSWORD" | sudo -S chown -R 999:999 /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis
        echo "$SUDO_PASSWORD" | sudo -S chmod -R 755 /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis

        sudo chown -R 999:999 /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres
        sudo chmod -R 700 /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres
        sudo chown -R 999:999 /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis
        sudo chmod -R 755 /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis

        # Use cached image if available
        if docker image inspect barcodeapi:latest >/dev/null 2>&1; then
          echo "Using cached image"
          $DOCKER_COMPOSE up -d
        else
          echo "Building fresh image"
          $DOCKER_COMPOSE build --no-cache api
          $DOCKER_COMPOSE up -d
        fi

        # Check container health
        check_container_health() {
            local container=$1
            local timeout=$2
            local start_time=$(date +%s)
            local end_time=$((start_time + timeout))

            while [ $(date +%s) -lt $end_time ]; do
                if $DOCKER_COMPOSE ps $container 2>/dev/null | grep -q "healthy"; then
                    echo "$container is healthy"
                    return 0
                fi
                echo "Waiting for $container to become healthy..."
                sleep 5
            done

            echo "$container failed to become healthy within $timeout seconds"
            return 1
        }

        # Check all services
        for service in "db" "redis" "api"; do
            if ! check_container_health "$service" 300; then
                echo "Service $service failed health check"
                $DOCKER_COMPOSE logs $service
                exit 1
            fi
        done

        echo "Backend deployment completed successfully"
        EOF

        # Make script executable
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod +x deploy_backend.sh

        # Run deployment script
        ./deploy_backend.sh

    - name: Verify deployment
      run: |
        # Check container status
        docker ps | grep -E "barcodeapi_(api|db|redis)"

        # Check API health
        curl -f http://localhost:8000/health || {
            echo "API health check failed"
            docker logs barcodeapi_api
            exit 1
        }

    - name: Run Database Migrations
      run: |
        cd /opt/thebarcodeapi/barcodeAPI

        # Determine docker compose command
        if command -v docker-compose &> /dev/null; then
          COMPOSE_CMD="docker-compose"
        else
          COMPOSE_CMD="docker compose"
        fi

        echo "Using compose command: $COMPOSE_CMD"

        # Set proper permissions
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown www-data:www-data /opt/thebarcodeapi/barcodeAPI/.env
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 /opt/thebarcodeapi/barcodeAPI/.env

        # Run migrations
        echo "Running migrations..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD exec -T api alembic upgrade head

        # Check migration status
        MIGRATION_STATUS=$?
        if [ $MIGRATION_STATUS -eq 0 ]; then
          echo "Database migrations completed successfully"
        else
          echo "Migration failed! Checking logs..."
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs api
        fi

        # Exit with migration status
        exit $MIGRATION_STATUS

    - name: Verify Backend Deployment
      run: |
        cd /opt/thebarcodeapi/barcodeAPI

        # Determine docker compose command
        if command -v docker-compose &> /dev/null; then
          COMPOSE_CMD="docker-compose"
        else
          COMPOSE_CMD="docker compose"
        fi

        # Create temporary env file with sudo
        # echo "Creating temporary environment file..."
        # echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c 'cat << EOF > /opt/thebarcodeapi/barcodeAPI/.env
        # DB_PASSWORD=${{ env.DB_PASSWORD }}
        # POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}
        # SECRET_KEY=${{ env.API_SECRET_KEY }}
        # MASTER_API_KEY=${{ env.API_MASTER_KEY }}
        # API_VERSION=${{ vars.API_VERSION }}
        # DATABASE_URL=postgresql+asyncpg://barcodeboachiefamily:${{ env.DB_PASSWORD }}@db/barcode_api
        # REDIS_URL=redis://redis:6379
        # ALGORITHM=HS256
        # ACCESS_TOKEN_EXPIRE_MINUTES=30
        # EOF'

        # Set proper permissions
        # echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown github-runner:github-runner /opt/thebarcodeapi/barcodeAPI/.env
        # echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 /opt/thebarcodeapi/barcodeAPI/.env

        echo "Verifying backend deployment..."

        echo "Checking Docker containers status:"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD ps

        echo "Checking container logs (last 10 lines):"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs --tail=10

        echo "Testing backend health:"
        MAX_RETRIES=3
        RETRY_COUNT=0
        until curl -f http://localhost:8000/health || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
          echo "Backend health check failed, retrying in 5 seconds..."
          sleep 5
          RETRY_COUNT=$((RETRY_COUNT + 1))
        done

        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
          echo "Backend health check failed after $MAX_RETRIES attempts"
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs api
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /opt/thebarcodeapi/barcodeAPI/.env
          exit 1
        fi

        echo "Backend verification completed successfully"

        # Cleanup
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /opt/thebarcodeapi/barcodeAPI/.env

    - name: Clean up
      if: always()
      run: |
        cd /opt/thebarcodeapi/barcodeAPI
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker system prune -f --volumes

    - name: Final cleanup
      if: always()
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /opt/thebarcodeapi/barcodeAPI/.env

    - name: Final Status Check
      run: |
        echo "Performing final status check..."

        # Check app containers
        if ! docker ps | grep -q "barcodeapi_api"; then
          echo "API container is not running!"
          exit 1
        fi

        # Check Redis
        if ! docker ps | grep -q "barcodeapi_redis"; then
          echo "Redis container is not running!"
          exit 1
        fi

        # Check Database
        if ! docker ps | grep -q "barcodeapi_db"; then
          echo "Database container is not running!"
          exit 1
        fi

        # Check API health
        if ! curl -s -f http://localhost:8000/health > /dev/null; then
          echo "API health check failed!"
          exit 1
        fi

        echo "All services are running correctly!"

  final-verification:
    runs-on: self-hosted
    needs: [frontend-deployment, backend-deployment]
    steps:

    - name: Clean up build artifacts
      if: always()
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -rf .next
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -rf build
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f package.json package-lock.json
        # Clean docker unused resources
        docker system prune -f --volumes

    - name: Notify on failure
      if: failure()
      run: |
        echo "============================================"
        echo "Deployment failed! Collecting diagnostic information..."
        echo "============================================"

        echo "PM2 Status:"
        pm2 list || true

        echo "Docker Container Status:"
        docker ps -a || true

        echo "Recent Docker Logs:"
        docker-compose -f /opt/thebarcodeapi/barcodeAPI/docker-compose.yml logs --tail=50 || true

        echo "Nginx Status:"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S systemctl status nginx || true

        echo "Cleaning up temporary files..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /tmp/env_vars
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /tmp/docker_vars
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /opt/thebarcodeapi/barcodeAPI/.env

        echo "============================================"
        # exit 1