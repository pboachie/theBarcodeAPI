name: theBarcodeApi Application Deployment

on:
  workflow_run:
    workflows: ["theBarcodeApi Infrastructure Setup"]
    branches: [main]
    types:
      - completed
  push:
    branches:
      - main
    tags:
      - 'v*.*.*' # For tags like v0.1.0
      - '*.*.*'  # For tags like 0.1.0 (without v prefix)
      - '*'      # Fallback for any other tag format if needed, be cautious with too broad patterns
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch or Tag to deploy'
        required: false
        default: 'main'

env:
  # Domain name for the application, used by web server configurations (e.g., in Nginx)
  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  # Deployment environment (e.g., staging, production)
  ENVIRONMENT: ${{ vars.ENVIRONMENT }}
  # Sudo password for privileged operations on the self-hosted runner
  SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
  # Database password for the main application user (e.g., barcodeboachiefamily)
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  # PostgreSQL superuser (postgres user) password
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  # Secret key used for JWT token generation and other security functions in the API
  API_SECRET_KEY: ${{ secrets.API_SECRET_KEY }}
  # Master API key for administrative or high-privilege API access
  API_MASTER_KEY: ${{ secrets.API_MASTER_KEY }}
  # Version of the API, used for documentation, releases, and potentially in build arguments
  API_VERSION: ${{ vars.API_VERSION }}

jobs:
  build-and-deploy-backend:
    runs-on: self-hosted
    # This job runs if the event is a push, manual workflow dispatch, or after infrastructure setup
    if: github.event_name == 'push' || github.event_name == 'workflow_dispatch' || (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    steps:
    # Determines the branch to checkout for the backend deployment.
    # For manual 'workflow_dispatch', it uses the workflow's own ref (branch or tag).
    # For other events, it defaults to 'main'.
    - name: Determine branch for backend deployment
      id: get_branch # Note: ID is same as in frontend job, but it's a local ID to this job.
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "branch=${{ github.event.inputs.branch || github.ref }}" >> $GITHUB_OUTPUT
        else # For push events (to main branch or a tag)
          echo "branch=${{ github.ref }}" >> $GITHUB_OUTPUT # Use the pushed ref (branch or tag)
        fi

    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for all branches and tags, enabling diffs against any prior commit.
        ref: ${{ steps.get_branch.outputs.branch }}

    # Verify that infrastructure is properly set up before proceeding
    - name: Verify infrastructure setup
      run: bash ./scripts/verify-infrastructure-setup.sh
      env:
        ENVIRONMENT: ${{ env.ENVIRONMENT }}

    # Executes a script to determine if there are changes in the backend codebase.
    # Outputs 'changes=true' or 'changes=false' to GITHUB_OUTPUT for use in subsequent steps.
    - name: Check for backend code changes
      id: check_backend_changes
      run: bash ./scripts/check-backend-changes.sh
      env:
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}

    # If backend changes are detected, this step cleans the target deployment directory
    # and copies the new backend files into it. A backup of the existing deployment is made first.
    - name: Clean and copy backend files to deployment directory
      if: steps.check_backend_changes.outputs.changes == 'true'
      run: |
        # Create backup of current deployment if it exists
        if [ -d "/opt/thebarcodeapi/barcodeApi" ]; then
          BACKUP_DIR="/opt/thebarcodeapi/${{ vars.ENVIRONMENT }}/backups/$(date +%Y%m%d_%H%M%S)"
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p "${BACKUP_DIR}"
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp -r /opt/thebarcodeapi/barcodeApi "${BACKUP_DIR}/"
          # Also backup docker-compose.yml if it exists
          if [ -f "/opt/thebarcodeapi/docker-compose.yml" ]; then
            echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp /opt/thebarcodeapi/docker-compose.yml "${BACKUP_DIR}/"
          fi
        fi

        # Clean the deployment directory
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -rf /opt/thebarcodeapi/barcodeApi/*

        # Copy new backend files
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp -r ./barcodeApi/* /opt/thebarcodeapi/barcodeApi/

        # Copy docker-compose.yml to the root deployment directory
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp ./docker-compose.yml /opt/thebarcodeapi/

        # Set proper permissions
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R $USER:$USER /opt/thebarcodeapi/barcodeApi
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod -R 755 /opt/thebarcodeapi/barcodeApi
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown $USER:$USER /opt/thebarcodeapi/docker-compose.yml
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 /opt/thebarcodeapi/docker-compose.yml

        # Debug output
        echo "Contents of deployment directory:"
        ls -la /opt/thebarcodeapi/barcodeApi/
        echo "Contents of root deployment directory:"
        ls -la /opt/thebarcodeapi/

    # Executes a script to create the .env file required by the backend application.
    # This file contains sensitive information and configuration details.
    - name: Create .env file for backend services
      run: |
        # Substitute all variables in the backend.env.template and output to .env
        envsubst < ./scripts/infra/templates/backend.env.template > ./barcodeApi/.env
        # Show the generated .env for debugging (remove or mask sensitive values in production)
        echo "Generated backend .env file:"
        cat ./barcodeApi/.env
      env:
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        API_SECRET_KEY: ${{ secrets.API_SECRET_KEY }}
        API_MASTER_KEY: ${{ secrets.API_MASTER_KEY }}
        API_VERSION: ${{ vars.API_VERSION }}
        ENVIRONMENT: ${{ vars.ENVIRONMENT }}
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }}

    # Ensure .env file is present in deployment directory before Docker Compose
    - name: Copy .env file to deployment directory
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp ./barcodeApi/.env /opt/thebarcodeapi/barcodeApi/.env
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown $USER:$USER /opt/thebarcodeapi/barcodeApi/.env
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 600 /opt/thebarcodeapi/barcodeApi/.env

    # Debug: Show contents of .env file in deployment directory (mask secrets in production)
    - name: Show deployed .env file contents
      run: |
        echo "Contents of /opt/thebarcodeapi/barcodeApi/.env (mask secrets in production):"
        echo "---"
        cat /opt/thebarcodeapi/barcodeApi/.env
        echo "---"

    # Fix Docker permissions before Docker operations
    - name: Fix Docker Permissions
      run: |
        # Add user to docker group if not already added
        if ! groups | grep -q docker; then
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S usermod -aG docker $USER
        fi

        # Fix Docker socket permissions
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 666 /var/run/docker.sock

        # Verify Docker access
        docker version

    # Stores the current Git commit hash into a .git-commit file within the backend deployment directory.
    # This helps in tracking which version of the code is currently deployed.
    - name: Store Git commit hash in backend deployment directory
      if: steps.check_backend_changes.outputs.changes == 'true'
      run: |
        git rev-parse HEAD > .git-commit
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp .git-commit /opt/thebarcodeapi/barcodeApi/

    # Sets up essential initial directory structure for the backend application,
    # including directories for persisted data (Postgres, Redis) and backups.
    - name: Setup initial directories for backend data and operations
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/barcodeApi
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/backups/

        # Create logs directory with proper permissions for container access
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/barcodeApi/logs
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R 1000:1000 /opt/thebarcodeapi/barcodeApi/logs
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod -R 755 /opt/thebarcodeapi/barcodeApi/logs

        # Ensure docker-compose.yml exists in deployment directory (always needed)
        if [ ! -f "/opt/thebarcodeapi/docker-compose.yml" ]; then
          echo "Copying docker-compose.yml to deployment directory..."
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp ./docker-compose.yml /opt/thebarcodeapi/
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown $USER:$USER /opt/thebarcodeapi/docker-compose.yml
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 /opt/thebarcodeapi/docker-compose.yml
        fi

        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R $USER:$USER /opt/thebarcodeapi/barcodeApi

    # Fix permissions for mounted volumes before starting containers
    - name: Fix permissions for mounted volumes
      run: |
        # Ensure proper permissions for logs directory that will be mounted
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/barcodeApi/logs
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R 1000:1000 /opt/thebarcodeapi/barcodeApi/logs
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod -R 775 /opt/thebarcodeapi/barcodeApi/logs

        # Also ensure data directory has proper permissions
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/barcodeApi/data
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R 1000:1000 /opt/thebarcodeapi/barcodeApi/data
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod -R 755 /opt/thebarcodeapi/barcodeApi/data

    # Executes the main backend deployment script.
    # This script is responsible for managing Docker Compose (down, up, build), handling data persistence,
    # database backups, and health checks for the backend services.
    - name: Check backend container status
      id: backend_status
      run: |
        # Check if services are running. The service names in docker-compose are barcodeapi, db, redis
        # Docker adds project name prefix, e.g. thebarcodeapi_barcodeapi_1, thebarcodeapi_db_1, thebarcodeapi_redis_1
        # Or possibly just barcodeapi_barcodeapi_1, etc. if COMPOSE_PROJECT_NAME is set to 'barcodeapi'
        # We will grep for the base service names.
        API_RUNNING=$(docker ps --format '{{.Names}}' | grep -E "_barcodeapi_|_api_" || echo "false")
        DB_RUNNING=$(docker ps --format '{{.Names}}' | grep -E "_db_|_postgres_" || echo "false")
        REDIS_RUNNING=$(docker ps --format '{{.Names}}' | grep -E "_redis_" || echo "false")

        if [ "$API_RUNNING" != "false" ] && [ "$DB_RUNNING" != "false" ] && [ "$REDIS_RUNNING" != "false" ]; then
          echo "ALL_BACKEND_SERVICES_RUNNING=true" >> $GITHUB_OUTPUT
        else
          echo "ALL_BACKEND_SERVICES_RUNNING=false" >> $GITHUB_OUTPUT
          echo "API Status: $API_RUNNING"
          echo "DB Status: $DB_RUNNING"
          echo "Redis Status: $REDIS_RUNNING"
        fi

    - name: Deploy backend services (barcodeapi, db, redis)
      env:
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }}
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
        DB_PASSWORD: ${{ env.DB_PASSWORD }}
        POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
        API_SECRET_KEY: ${{ env.API_SECRET_KEY }}
        API_MASTER_KEY: ${{ env.API_MASTER_KEY }}
        API_VERSION: ${{ vars.API_VERSION }}
      run: |
        cd /opt/thebarcodeapi # Ensure we are in the directory where docker-compose.yml is
        COMPOSE_FILE_PATH="./docker-compose.yml" # Explicitly define path

        # Determine docker compose command
        if command -v docker-compose &> /dev/null; then
            COMPOSE_CMD="docker-compose -f $COMPOSE_FILE_PATH"
        elif command -v docker &> /dev/null && docker compose version &> /dev/null; then
            COMPOSE_CMD="docker compose -f $COMPOSE_FILE_PATH"
        else
            echo "Neither docker-compose nor docker compose found!"
            exit 1
        fi

        echo "Changes detected: ${{ steps.check_backend_changes.outputs.changes }}"
        echo "All backend services running: ${{ steps.backend_status.outputs.ALL_BACKEND_SERVICES_RUNNING }}"

        if [ "${{ steps.check_backend_changes.outputs.changes }}" == "true" ]; then
          echo "Backend changes detected. Building and deploying barcodeapi, db, redis..."
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD down # Bring down existing services before build
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD up -d --build --force-recreate --remove-orphans barcodeapi db redis
        elif [ "${{ steps.backend_status.outputs.ALL_BACKEND_SERVICES_RUNNING }}" == "false" ]; then
          echo "No backend changes, but some services are not running. Pruning images and rebuilding barcodeapi, db, redis with no-cache..."
          # Prune images - careful with this, ensure it targets correctly or rely on docker-compose build --no-cache
          # For now, let's rely on --no-cache for the build. Pruning specific images can be tricky if names change.
          # Example for pruning:
          # IMAGE_API=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "barcodeapi") || true
          # IMAGE_DB=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "postgres") || true # Or the specific image name used
          # IMAGE_REDIS=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "redis") || true # Or the specific image name used
          # if [ -n "$IMAGE_API" ]; then echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker rmi $IMAGE_API || true; fi
          # if [ -n "$IMAGE_DB" ]; then echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker rmi $IMAGE_DB || true; fi
          # if [ -n "$IMAGE_REDIS" ]; then echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker rmi $IMAGE_REDIS || true; fi
          # echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker system prune -af --volumes # This is aggressive, reconsider if needed here

          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD down
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD up -d --build --no-cache --force-recreate --remove-orphans barcodeapi db redis
        else
          echo "No backend changes and all backend services are running. Ensuring services are up..."
          # Just ensure they are up, no build needed.
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD up -d --no-deps --remove-orphans barcodeapi db redis
        fi
        # Health check after deployment attempt
        # This part can be extracted from deploy-backend-docker.sh or kept there if the script is still used.
        # For now, assuming a basic health check here.
        sleep 15 # Give services time to start
        MAX_RETRIES=5
        RETRY_DELAY=10
        ATTEMPT=1
        while [ $ATTEMPT -le $MAX_RETRIES ]; do
          echo "Health check attempt $ATTEMPT/$MAX_RETRIES for backend API..."
          if curl -f http://localhost:8000/health; then
            echo "Backend API is healthy."
            break
          fi
          echo "Health check failed. Retrying in $RETRY_DELAY seconds..."
          sleep $RETRY_DELAY
          ATTEMPT=$((ATTEMPT + 1))
        done

        if [ $ATTEMPT -gt $MAX_RETRIES ]; then
          echo "❌ Backend API health check failed after $MAX_RETRIES attempts."
          echo "Displaying logs for barcodeapi, db, redis:"
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs --tail 100 barcodeapi || echo "Could not get barcodeapi logs"
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs --tail 100 db || echo "Could not get db logs"
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs --tail 100 redis || echo "Could not get redis logs"
          echo "All containers (docker ps -a):"
          docker ps -a
          echo "Individual container logs (if any):"
          for cname in $(docker ps -a --format '{{.Names}}'); do
            echo "--- Logs for $cname ---"
            docker logs $cname || echo "No logs for $cname"
            echo "----------------------"
          done
          exit 1
        fi

    - name: Verify backend deployment
      run: |
        # Check container status (handle both possible naming patterns)
        docker ps | grep -E "(barcodeapi_(api|db|redis)|thebarcodeapi_(barcodeapi|db|redis))"

        # Check API health
        curl -f http://localhost:8000/health || {
            echo "API health check failed."
            # Show logs for any API container found
            docker logs $(docker ps --format "table {{.Names}}" | grep -E "(barcodeapi|api)" | head -1) || echo "Could not get API logs"
            exit 1
        }

    # Executes a script to run database migrations using Alembic within the API container.
    - name: Run database migrations for backend
      run: bash ./scripts/run-migrations.sh
      env:
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }} # Script uses sudo for `docker compose exec`.

    # Verifies the overall backend deployment by checking Docker container statuses,
    # recent logs, and performing a health check against the API endpoint.
    # It also handles cleanup of the temporary .env file used during verification.
    - name: Verify backend deployment status and API health
      run: |
        cd /opt/thebarcodeapi/barcodeApi # Script expects to be in this directory for docker-compose commands.

        # Determine docker compose command
        if command -v docker-compose >/dev/null 2>&1; then
          COMPOSE_CMD="docker-compose"
        else
          COMPOSE_CMD="docker compose"
        fi

        # Set proper permissions
        # echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown $USER:$USER /opt/thebarcodeapi/barcodeApi/.env
        # echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 /opt/thebarcodeapi/barcodeApi/.env

        echo "Verifying backend deployment..."

        echo "Checking Docker containers status:"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD ps

        echo "Checking container logs (last 10 lines):"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs --tail=10

        echo "Testing backend health:"
        MAX_RETRIES=3
        RETRY_COUNT=0
        until curl -f http://localhost:8000/health || [ $RETRY_COUNT -eq $MAX_RETRIES ]; do
          echo "Backend health check failed, retrying in 5 seconds..."
          sleep 5
          RETRY_COUNT=$((RETRY_COUNT + 1))
        done

        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
          echo "Backend health check failed after $MAX_RETRIES attempts"
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs barcodeapi
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /opt/thebarcodeapi/barcodeApi/.env
          exit 1
        fi

        echo "Backend verification completed successfully"

        # Cleanup of the .env file specific to this verification step; the main .env for the container is managed by create-backend-env-file.sh.
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /opt/thebarcodeapi/barcodeApi/.env

    # Performs a Docker system prune to remove unused Docker data (images, containers, volumes, networks)
    # to free up disk space. Runs even if previous steps in the job fail.
    - name: Clean up unused Docker resources on runner
      if: always()
      run: |
        cd /opt/thebarcodeapi/barcodeApi # Context for docker-compose related prune if applicable, though `docker system prune` is global.
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker system prune -f --volumes

    # Final cleanup of the backend .env file created by 'Create .env file for backend services' step.
    # This ensures that sensitive data in this specific .env file (if different from the one inside Docker) is removed after deployment.
    - name: Final cleanup of backend .env file from host
      if: always()
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /opt/thebarcodeapi/barcodeApi/.env

    # Performs a final status check on all critical services (API, Redis, Database)
    # to ensure they are running and responsive after the deployment process.
    - name: Final status check of all backend services
      run: |
        echo "Performing final status check..."

        # Check app containers (handle both possible naming patterns)
        if ! docker ps | grep -E "(barcodeapi_api|thebarcodeapi_barcodeapi)"; then
          echo "API container is not running!"
          docker ps -a | grep -E "(barcodeapi|api)" || echo "No API containers found"
          exit 1
        fi

        # Check Redis (handle both possible naming patterns)
        if ! docker ps | grep -E "(barcodeapi_redis|thebarcodeapi_redis)"; then
          echo "Redis container is not running!"
          docker ps -a | grep -E "(redis)" || echo "No Redis containers found"
          exit 1
        fi

        # Check Database (handle both possible naming patterns)
        if ! docker ps | grep -E "(barcodeapi_db|thebarcodeapi_db)"; then
          echo "Database container is not running!"
          docker ps -a | grep -E "(db|postgres)" || echo "No DB containers found"
          exit 1
        fi

        # Check API health
        if ! curl -s -f http://localhost:8000/health > /dev/null; then
          echo "API health check failed!"
          exit 1
        fi

        echo "All services are running correctly!"

  build-and-deploy-frontend:
    runs-on: self-hosted
    needs: build-and-deploy-backend
    steps:
    # Check infrastructure workflow status when triggered by workflow_run
    - name: Check infrastructure workflow status
      if: github.event_name == 'workflow_run'
      run: |
        echo "Infrastructure workflow completed with status: ${{ github.event.workflow_run.conclusion }}"
        if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
          echo "Infrastructure workflow did not complete successfully. Cannot proceed with application deployment."
          exit 1
        fi

    # Determines the branch to checkout.
    # For manual 'workflow_dispatch', it uses the 'branch' input or the current ref_name if input is not provided.
    # For other events (like a push, though the trigger is currently commented out), it defaults to github.ref_name.
    - name: Determine branch to deploy
      id: get_branch
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "branch=${{ github.event.inputs.branch || github.ref_name }}" >> $GITHUB_OUTPUT
        else
          echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT
        fi

    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        ref: ${{ steps.get_branch.outputs.branch }}

    # Verify that infrastructure is properly set up before proceeding
    - name: Verify infrastructure setup
      run: bash ./scripts/verify-infrastructure-setup.sh
      env:
        ENVIRONMENT: ${{ env.ENVIRONMENT }}

    # Executes a script to determine if there are changes in the frontend codebase compared to the last deployed commit.
    # Outputs 'changes=true' or 'changes=false' to GITHUB_OUTPUT, which is used by subsequent steps.
    - name: Check for frontend code changes
      id: check_frontend_changes
      run: bash ./scripts/check-frontend-changes.sh
      env:
        ENVIRONMENT: ${{ env.ENVIRONMENT }}

    # Validates that essential environment variables are set if frontend changes are detected and a build/deployment is needed.
    - name: Validate essential environment variables
      if: steps.check_frontend_changes.outputs.changes == 'true'
      run: |
        for var in ENVIRONMENT; do # Removed backend specific vars
          if [ -z "${!var}" ]; then
            echo "Error: $var is not set"
            exit 1
          fi
        done

    - name: Use Node.js
      if: steps.check_frontend_changes.outputs.changes == 'true'
      uses: actions/setup-node@v3
      with:
        node-version: '20.x'
        cache: 'npm'
        cache-dependency-path: 'barcodeFrontend/package-lock.json'

    # Caches Next.js build artifacts (.next/cache) and downloaded dependencies (node_modules)
    # to speed up subsequent builds if frontend changes are detected.
    # The cache key is composed of the runner's OS, a hash of package-lock.json, and hashes of all JS/TS(X) files.
    # A less specific restore key (without source file hashes) is provided as a fallback.
    - name: Cache Next.js build artifacts and dependencies
      if: steps.check_frontend_changes.outputs.changes == 'true'
      uses: actions/cache@v3
      with:
        path: |
          barcodeFrontend/.next/cache
          barcodeFrontend/node_modules
        key: ${{ runner.os }}-nextjs-${{ hashFiles('barcodeFrontend/package-lock.json') }}-${{ hashFiles('barcodeFrontend/**/*.js', 'barcodeFrontend/**/*.jsx', 'barcodeFrontend/**/*.ts', 'barcodeFrontend/**/*.tsx') }}
        restore-keys: |
          ${{ runner.os }}-nextjs-${{ hashFiles('barcodeFrontend/package-lock.json') }}-

    # Installs npm dependencies using 'npm ci' for a clean, reproducible install from package-lock.json.
    # Then, it runs linting and the build process for the Next.js application.
    - name: Install dependencies, lint, and build frontend
      if: steps.check_frontend_changes.outputs.changes == 'true'
      working-directory: barcodeFrontend
      run: |
        npm ci
        npm run lint
        npm run build

    # Clean up Docker containers, images, and volumes before frontend build - MOVED TO BACKEND, this might be redundant or specific for frontend
    # - name: Clean up Docker containers, images, and volumes before frontend build
    #   run: |
    #     echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker-compose down -v || true
    #     echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker system prune -af --volumes || true

    # Setup Environment Variables for Docker - This step might be partially needed for frontend if it writes to /opt/thebarcodeapi/.env
    # For now, assuming frontend doesn't need to write to the global .env, only read.
    # The docker-compose.yml copy is essential and should be present.
    - name: Ensure docker-compose.yml exists in deployment directory
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi
        if [ ! -f "/opt/thebarcodeapi/docker-compose.yml" ]; then
          echo "Copying docker-compose.yml to deployment directory..."
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp ./docker-compose.yml /opt/thebarcodeapi/
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown $USER:$USER /opt/thebarcodeapi/docker-compose.yml
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 /opt/thebarcodeapi/docker-compose.yml
        fi
        # Ensure frontend deployment directory exists and has correct permissions
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p /opt/thebarcodeapi/barcodeFrontend
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R $USER:$USER /opt/thebarcodeapi/barcodeFrontend

    - name: Check frontend container status
      id: frontend_status
      run: |
        # Check if barcodefrontend service is running
        # Docker adds project name prefix, e.g. thebarcodeapi_barcodefrontend_1
        # We will grep for the base service name.
        FRONTEND_CONTAINER_NAME=$(docker ps --format '{{.Names}}' | grep -E "_barcodefrontend_" || echo "false")
        if [ "$FRONTEND_CONTAINER_NAME" != "false" ]; then
          echo "FRONTEND_RUNNING=true" >> $GITHUB_OUTPUT
          echo "Frontend container ($FRONTEND_CONTAINER_NAME) is running."
        else
          echo "FRONTEND_RUNNING=false" >> $GITHUB_OUTPUT
          echo "Frontend container is not running."
        fi

    - name: Deploy Frontend using Docker
      env:
        ENVIRONMENT: ${{ env.ENVIRONMENT }}
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }}
        PROJECT_VERSION: ${{ env.API_VERSION }} # Frontend might use this
        # STEPS_CHECK_FRONTEND_CHANGES_OUTPUTS_CHANGES: ${{ steps.check_frontend_changes.outputs.changes }} # Will be used in the run script directly
      run: |
        # Copy frontend files if changes are detected or if the container needs to be rebuilt
        if [ "${{ steps.check_frontend_changes.outputs.changes }}" == "true" ] || [ "${{ steps.frontend_status.outputs.FRONTEND_RUNNING }}" == "false" ]; then
          echo "Copying frontend files to /opt/thebarcodeapi/barcodeFrontend..."
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -rf /opt/thebarcodeapi/barcodeFrontend/* # Clean before copy
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp -r ./barcodeFrontend/* /opt/thebarcodeapi/barcodeFrontend/
          # Ensure Dockerfile is in the correct context for docker-compose build
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S cp ./barcodeFrontend/Dockerfile /opt/thebarcodeapi/barcodeFrontend/Dockerfile
          # Set proper ownership for the copied frontend files
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R $USER:$USER /opt/thebarcodeapi/barcodeFrontend
        else
          echo "No frontend changes and frontend is running. Skipping file copy."
        fi

        cd /opt/thebarcodeapi # Ensure we are in the directory where docker-compose.yml is
        COMPOSE_FILE_PATH="./docker-compose.yml"

        # Determine docker compose command
        if command -v docker-compose &> /dev/null; then
            COMPOSE_CMD="docker-compose -f $COMPOSE_FILE_PATH"
        elif command -v docker &> /dev/null && docker compose version &> /dev/null; then
            COMPOSE_CMD="docker compose -f $COMPOSE_FILE_PATH"
        else
            echo "Neither docker-compose nor docker compose found!"
            exit 1
        fi

        echo "Frontend changes detected: ${{ steps.check_frontend_changes.outputs.changes }}"
        echo "Frontend running: ${{ steps.frontend_status.outputs.FRONTEND_RUNNING }}"

        BUILD_CMD=""
        if [ "${{ steps.check_frontend_changes.outputs.changes }}" == "true" ]; then
          echo "Frontend changes detected. Building and deploying barcodefrontend..."
          BUILD_CMD="$COMPOSE_CMD up -d --no-deps --build barcodefrontend --force-recreate --remove-orphans"
        elif [ "${{ steps.frontend_status.outputs.FRONTEND_RUNNING }}" == "false" ]; then
          echo "No frontend changes, but frontend is not running. Pruning image and rebuilding barcodefrontend with no-cache..."
          # Pruning specific image can be done here if needed, e.g.,
          # IMAGE_FRONTEND=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep "barcodefrontend") || true
          # if [ -n "$IMAGE_FRONTEND" ]; then echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker rmi $IMAGE_FRONTEND || true; fi
          BUILD_CMD="$COMPOSE_CMD up -d --no-deps --build --no-cache barcodefrontend --force-recreate --remove-orphans"
        else
          echo "No frontend changes and frontend is running. Ensuring service is up..."
          BUILD_CMD="$COMPOSE_CMD up -d --no-deps barcodefrontend --remove-orphans"
        fi

        # Execute the determined command with retry logic
        MAX_RETRIES=3 # Reduced from 5 for quicker feedback if it fails consistently
        RETRY_DELAY=5
        ATTEMPT=1
        while [ $ATTEMPT -le $MAX_RETRIES ]; do
          echo "Frontend Docker Compose command attempt $ATTEMPT/$MAX_RETRIES..."
          echo "Executing: echo \"${{ env.SUDO_PASSWORD }}\" | sudo -S $BUILD_CMD"
          # Wrap the command in a subshell to handle potential errors correctly with sudo
          (echo "${{ env.SUDO_PASSWORD }}" | sudo -S $BUILD_CMD) && CMD_SUCCESS=true || CMD_SUCCESS=false

          if [ "$CMD_SUCCESS" = true ]; then
            echo "Frontend deployment command successful."
            break
          fi
          echo "Frontend deployment command failed. Retrying in $RETRY_DELAY seconds..."
          sleep $RETRY_DELAY
          ATTEMPT=$((ATTEMPT + 1))
        done

        if [ "$CMD_SUCCESS" != true ]; then
          echo "❌ Frontend Docker Compose command failed after $MAX_RETRIES attempts."
          echo "Displaying logs for barcodefrontend:"
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs --tail 50 barcodefrontend || echo "Could not get barcodefrontend logs"
          exit 1
        fi

        # Health check for frontend (e.g., curl localhost:3000)
        echo "Performing frontend health check..."
        sleep 10 # Give frontend time to start
        FRONTEND_HEALTH_MAX_RETRIES=3
        FRONTEND_HEALTH_ATTEMPT=1
        while [ $FRONTEND_HEALTH_ATTEMPT -le $FRONTEND_HEALTH_MAX_RETRIES ]; do
            if curl -f http://localhost:3000; then # Adjust URL/port if needed
                echo "Frontend is healthy."
                break
            fi
            echo "Frontend health check failed (attempt $FRONTEND_HEALTH_ATTEMPT/$FRONTEND_HEALTH_MAX_RETRIES). Retrying in $RETRY_DELAY seconds..."
            sleep $RETRY_DELAY
            FRONTEND_HEALTH_ATTEMPT=$((FRONTEND_HEALTH_ATTEMPT + 1))
        done

        if [ $FRONTEND_HEALTH_ATTEMPT -gt $FRONTEND_HEALTH_MAX_RETRIES ]; then
            echo "❌ Frontend health check failed after $FRONTEND_HEALTH_MAX_RETRIES attempts."
            echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs --tail 50 barcodefrontend || echo "Could not get barcodefrontend logs"
            exit 1
        fi
        echo "Frontend deployed and healthy."

    - name: Store Git commit hash for frontend deployment
      if: success() # Only run if the deployment was successful
      run: |
        TARGET_DIR="/opt/thebarcodeapi/${{ env.ENVIRONMENT }}/current"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p "${TARGET_DIR}"
        echo "Storing current git commit $(git rev-parse HEAD) to ${TARGET_DIR}/.git-commit"
        git rev-parse HEAD | echo "${{ env.SUDO_PASSWORD }}" | sudo -S tee "${TARGET_DIR}/.git-commit" > /dev/null
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown $USER:$USER "${TARGET_DIR}/.git-commit"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 "${TARGET_DIR}/.git-commit"
        echo "Contents of ${TARGET_DIR}/.git-commit:"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S cat "${TARGET_DIR}/.git-commit"

  final-verification: # This job runs after both frontend and backend deployments.
    runs-on: self-hosted
    needs: [build-and-deploy-frontend] # Ensures it runs only if build-and-deploy-frontend succeeds
    if: always() # This job should always run to report success or failure
    steps:
    - name: Report deployment status
      run: |
        if [[ "${{ needs.build-and-deploy-frontend.result }}" == "success" ]]; then
          echo "✅ Overall deployment successful!"
        else
          echo "❌ Overall deployment failed."
        fi

    # Cleans up build artifacts (like .next, build directories, package files) from the runner's workspace.
    # Also runs a Docker system prune, which might be redundant if the backend job already did it.
    - name: Clean up build artifacts from runner workspace
      # This step runs regardless of the success or failure of previous jobs/steps within this 'final-verification' job.
      # The job itself runs 'always()'.
      run: |
        echo "Cleaning up runner workspace..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -rf .next
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -rf build
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f package.json package-lock.json
        # Clean docker unused resources - this is a repeat from the backend job, consider if necessary here.
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker system prune -f --volumes

    # If any of the preceding jobs (build-and-deploy-frontend) failed,
    # this step collects diagnostic information from Docker and Nginx, and cleans up temporary files.
    - name: Collect diagnostics on deployment failure
      if: needs.build-and-deploy-frontend.result != 'success'
      run: |
        echo "============================================"
        echo "Deployment failed! Collecting diagnostic information..."
        echo "============================================"

        echo "Docker Container Status:"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S docker ps -a || true

        echo "Recent Docker Logs (from /opt/thebarcodeapi/docker-compose.yml):"
        if [ -f "/opt/thebarcodeapi/docker-compose.yml" ]; then
          # Determine docker compose command
          if command -v docker-compose &> /dev/null; then
              COMPOSE_CMD="docker-compose -f /opt/thebarcodeapi/docker-compose.yml"
          elif command -v docker &> /dev/null && docker compose version &> /dev/null; then
              COMPOSE_CMD="docker compose -f /opt/thebarcodeapi/docker-compose.yml"
          else
              COMPOSE_CMD=""
              echo "Neither docker-compose nor docker compose found for fetching logs!"
          fi
          if [ -n "$COMPOSE_CMD" ]; then
            echo "${{ env.SUDO_PASSWORD }}" | sudo -S $COMPOSE_CMD logs --tail=100 || true # Increased tail to 100
          fi
        else
          echo "No docker-compose.yml file found at /opt/thebarcodeapi/docker-compose.yml for logs"
        fi

        echo "Nginx Status:"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S systemctl status nginx || true

        echo "Cleaning up temporary files..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /tmp/env_vars
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /tmp/docker_vars
        # The .env file at /opt/thebarcodeapi/barcodeApi/.env is cleaned up by the backend job.
        # No need to repeat here unless it's a different .env file.

        echo "============================================"
        # exit 1 # The job will fail due to the 'if' condition on 'needs' if there was a failure.