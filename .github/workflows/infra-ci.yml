name: theBarcodeApi Infrastructure Setup

on:
  workflow_dispatch:

env:
  # Domain name for the application, used by Nginx and other services.
  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  # Deployment environment (e.g., staging, production). Used for path creation and configuration templating.
  ENVIRONMENT: ${{ vars.ENVIRONMENT }}
  # Sudo password for privileged operations on the self-hosted runner.
  SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
  # Database password for the main application user.
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  # PostgreSQL superuser (postgres user) password.
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  # Secret key for API authentication (e.g., JWT signing).
  API_SECRET_KEY: ${{ secrets.API_SECRET_KEY }}
  # Master API key for administrative API access.
  API_MASTER_KEY: ${{ secrets.API_MASTER_KEY }}
  # Version of the API, used in .env files and potentially for tagging.
  API_VERSION: ${{ vars.API_VERSION }}

jobs:
  infra-ci-job:
    name: Setup Server Infrastructure
    runs-on: self-hosted

    steps:
    - name: Checkout repository code
      uses: actions/checkout@v3

    # Sets up the basic directory structure needed for application data, releases, and backups.
    # These directories are primarily for Docker volumes and PM2 application storage.
    - name: Setup initial application directories
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p "/opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p "/opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p "/opt/thebarcodeapi/${ENVIRONMENT}/backups"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R github-runner:github-runner "/opt/thebarcodeapi/${ENVIRONMENT}/releases" # Ensure runner owns release parent

    # - name: Configure sudoers # This section is commented out due to security concerns.
    #   run: |
    #     echo "Configuring sudoers..."
    #     echo "${{ env.SUDO_PASSWORD }}" | sudo -S cat << 'EOF' | sudo tee /etc/sudoers.d/github-runner
    #     # PM2 related commands
    #     github-runner ALL=(ALL) NOPASSWD: /usr/bin/pm2
    #     github-runner ALL=(ALL) NOPASSWD: /usr/bin/npm

    #     # System service commands
    #     github-runner ALL=(ALL) NOPASSWD: /bin/systemctl restart nginx
    #     github-runner ALL=(ALL) NOPASSWD: /bin/systemctl reload nginx
    #     github-runner ALL=(ALL) NOPASSWD: /bin/systemctl restart docker
    #     github-runner ALL=(ALL) NOPASSWD: /usr/sbin/nginx -t

    #     # Directory and file operations
    #     github-runner ALL=(ALL) NOPASSWD: /bin/mkdir -p /opt/thebarcodeapi/*
    #     github-runner ALL=(ALL) NOPASSWD: /bin/chown -R * /opt/thebarcodeapi/*
    #     github-runner ALL=(ALL) NOPASSWD: /bin/chmod -R * /opt/thebarcodeapi/*
    #     github-runner ALL=(ALL) NOPASSWD: /bin/rm -f /opt/thebarcodeapi/*
    #     github-runner ALL=(ALL) NOPASSWD: /bin/rm -rf /opt/thebarcodeapi/*
    #     github-runner ALL=(ALL) NOPASSWD: /bin/cp -R * /opt/thebarcodeapi/*
    #     github-runner ALL=(ALL) NOPASSWD: /bin/mv * /opt/thebarcodeapi/*
    #     github-runner ALL=(ALL) NOPASSWD: /bin/ln -sf * /opt/thebarcodeapi/*

    #     # Docker related
    #     github-runner ALL=(ALL) NOPASSWD: /usr/bin/docker
    #     github-runner ALL=(ALL) NOPASSWD: /usr/local/bin/docker-compose
    #     github-runner ALL=(ALL) NOPASSWD: /usr/bin/docker-compose

    #     # Temp directory operations
    #     github-runner ALL=(ALL) NOPASSWD: /bin/rm -f /tmp/env_vars
    #     github-runner ALL=(ALL) NOPASSWD: /bin/rm -f /tmp/docker_vars
    #     github-runner ALL=(ALL) NOPASSWD: /usr/bin/tee /tmp/env_vars
    #     github-runner ALL=(ALL) NOPASSWD: /usr/bin/tee /tmp/docker_vars

    #     # Package management
    #     github-runner ALL=(ALL) NOPASSWD: /usr/bin/apt-get update
    #     github-runner ALL=(ALL) NOPASSWD: /usr/bin/apt-get upgrade -y
    #     github-runner ALL=(ALL) NOPASSWD: /usr/bin/apt-get install -y *

    #     # Group management
    #     github-runner ALL=(ALL) NOPASSWD: /usr/sbin/usermod -aG docker github-runner

    #     # Allow nginx configuration
    #     github-runner ALL=(ALL) NOPASSWD: /bin/cp * /etc/nginx/sites-available/*
    #     github-runner ALL=(ALL) NOPASSWD: /bin/ln -sf /etc/nginx/sites-available/* /etc/nginx/sites-enabled/*
    #     EOF

    #     sudo chmod 0440 /etc/sudoers.d/github-runner
    # IMPORTANT: The commented-out 'Configure sudoers' step below grants broad, passwordless sudo permissions
    # to the github-runner user. This poses a SIGNIFICANT SECURITY RISK by allowing the runner to execute
    # many commands as root without a password. If you need to grant sudo permissions, it is crucial to:
    # 1. Review each command carefully.
    # 2. Apply the Principle of Least Privilege: Only grant NOPASSWD access to the *specific* commands
    #    that are absolutely necessary for the workflow to function. Avoid wildcards.
    # 3. Regularly audit these permissions.
    # Consider alternative approaches that do not require broad sudo access if possible.

    # Ensures the github-runner user has the necessary .pm2 directory and permissions for PM2 to manage applications.
    - name: Set up PM2 home directory and permissions
      run: |
        # Create PM2 home directory with correct permissions if it doesn't exist
        mkdir -p /home/github-runner/.pm2
        chmod 700 /home/github-runner/.pm2

        # Ensure PM2 files are owned by github-runner
        touch /home/github-runner/.pm2/pm2.log
        chmod 600 /home/github-runner/.pm2/pm2.log

        # Create PM2 startup script directory
        mkdir -p /home/github-runner/.pm2/logs
        chmod 700 /home/github-runner/.pm2/logs

    # Updates system packages (apt update && apt upgrade). Continues on error as some updates might not be critical.
    # Script: scripts/infra/update-system.sh
    - name: Update system packages
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash ./scripts/infra/update-system.sh
      continue-on-error: true # Allow workflow to continue if minor update errors occur.

    # Installs essential dependencies like Nginx, Node.js, PM2, Docker, and Docker Compose.
    # Script: scripts/infra/install-dependencies.sh
    - name: Check and install system dependencies
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash ./scripts/infra/install-dependencies.sh
      env:
        # SUDO_PASSWORD is inherited by the script when using `sudo -S`,
        # but explicitly listed here for clarity if the script's sudo usage changes.
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }}

    # Creates a temporary file (/tmp/env_vars) containing all necessary environment variables.
    # This file is sourced by subsequent scripts, centralizing environment variable management for this workflow.
    - name: Create global environment variables file for scripts
      run: |
        echo "Creating global /tmp/env_vars file..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c "cat > /tmp/env_vars << 'EOF'
        DOMAIN_NAME=${{ env.DOMAIN_NAME }} # For Nginx config and other services
        ENVIRONMENT=${{ env.ENVIRONMENT }} # For path creation, naming conventions, templates
        NODE_ENV=${{ env.ENVIRONMENT }} # For Node.js applications, often 'production' or 'development'
        SUDO_PASSWORD=${{ env.SUDO_PASSWORD }} # For scripts that need to run sudo commands internally
        API_SECRET_KEY=${{ env.API_SECRET_KEY }} # For backend .env template
        API_MASTER_KEY=${{ env.API_MASTER_KEY }} # For backend .env template
        DB_PASSWORD=${{ env.DB_PASSWORD }} # For backend .env and Docker Compose template
        POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }} # For backend .env and Docker Compose template
        API_VERSION=${{ env.API_VERSION }} # For backend .env template
        ALGORITHM=HS256 # Default for JWT, used in backend .env
        ACCESS_TOKEN_EXPIRE_MINUTES=30 # Default for JWT, used in backend .env
        REDIS_URL=redis://redis:6379/1 # Default Redis connection string
        SYNC_DATABASE_URL=postgresql+asyncpg://barcodeboachiefamily:${{ env.DB_PASSWORD }}@db/barcode_api # DB connection for sync operations
        LOG_DIRECTORY=/app/logs # Default log directory for backend (inside container)
        SECRET_KEY=${{ env.API_SECRET_KEY }} # Duplicate of API_SECRET_KEY, review for consistency
        MASTER_API_KEY=${{ env.API_MASTER_KEY }} # Duplicate of API_MASTER_KEY, review for consistency
        DATABASE_URL=postgresql+asyncpg://barcodeboachiefamily:${{ env.DB_PASSWORD }}@db/barcode_api # Main database connection string
        EOF"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 644 /tmp/env_vars # Readable by all, but owned by root. This is fine as scripts using it run with sudo.

    # Configures Nginx as a reverse proxy for frontend and backend services.
    # Script: scripts/infra/configure-nginx.sh
    - name: Configure Nginx reverse proxy
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash ./scripts/infra/configure-nginx.sh
      env:
        # This script sources /tmp/env_vars for DOMAIN_NAME and other variables.
        # SUDO_PASSWORD is used here to execute the script with sudo.
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }}

    # Configures PM2 to manage the frontend Node.js application.
    # This includes templating the ecosystem.config.js file.
    # Script: scripts/infra/configure-pm2.sh
    - name: Configure PM2 for frontend application
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash ./scripts/infra/configure-pm2.sh
      env:
        # This script sources /tmp/env_vars for ENVIRONMENT and SUDO_PASSWORD.
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }}

    # Debugging step: List contents of the source directory for backend code.
    - name: List source directory contents (Before backend setup)
      run: ls -l /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI/barcodeAPI/

    # Debugging step: List contents of the current working directory.
    - name: List current working directory contents (Before backend setup)
      run: ls -l .

    # Sets up the Docker environment for the backend: copies backend code, templates Docker Compose and .env files,
    # sets up backup scripts, and other necessary configurations.
    # Script: scripts/infra/setup-docker-env.sh
    - name: Configure backend Docker environment and services
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash ./scripts/infra/setup-docker-env.sh
      env:
        # This script sources /tmp/env_vars for numerous variables (DB passwords, API keys, etc.).
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }}

    # Debugging step: List contents of the source directory for backend code after setup.
    - name: List source directory contents (After backend setup)
      run: ls -l /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI/barcodeAPI/

    # Debugging step: List contents of the backend deployment directory after setup.
    - name: List backend deployment directory contents (After backend setup)
      run: ls -l /opt/thebarcodeapi/barcodeAPI/

    # Corrects file and directory permissions across the application deployment path.
    # Script: scripts/infra/fix-permissions.sh
    - name: Fix file and directory permissions
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash ./scripts/infra/fix-permissions.sh
      env:
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }} # Script uses sudo for its operations.
        # ENVIRONMENT is sourced from /tmp/env_vars by the script.

    # Configures scripts and cron jobs for coordinating database and Redis backups.
    # Script: scripts/infra/configure-backup-coordination.sh
    - name: Configure backup coordination scripts and cron job
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash ./scripts/infra/configure-backup-coordination.sh
      env:
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }} # Script uses sudo for file operations and crontab.
        # ENVIRONMENT is sourced from /tmp/env_vars by the script.

    # Sets up a cleanup script and cron job for removing old releases, backups, and pruning Docker.
    # Script: scripts/infra/add-cleanup-routine.sh
    - name: Add cleanup routine script and cron job
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash ./scripts/infra/add-cleanup-routine.sh
      env:
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }} # Script uses sudo for file operations and crontab.
        # ENVIRONMENT is sourced from /tmp/env_vars by the script.

    # Verifies the overall infrastructure setup, including critical file existence and permissions.
    # This step now incorporates checks previously in the "Error Check" step.
    # Script: scripts/infra/verify-setup.sh
    - name: Verify infrastructure setup and critical file integrity
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash ./scripts/infra/verify-setup.sh
      env:
        SUDO_PASSWORD: ${{ env.SUDO_PASSWORD }} # Script uses sudo for its checks.
        # ENVIRONMENT is sourced from /tmp/env_vars by the script.

    # Verifies that essential files and directories exist within the checked-out repository structure.
    # This helps catch issues if the repository structure changes unexpectedly.
    - name: Verify basic repository structure for backend
      run: |
        if [ ! -d "barcodeAPI" ]; then
          echo "Error: barcodeAPI directory not found!"
          exit 1
        fi

        if [ ! -f "barcodeAPI/requirements.txt" ]; then
          echo "Error: requirements.txt not found in barcodeAPI directory!"
          exit 1
        fi

        if [ ! -f "barcodeAPI/start.sh" ]; then
          echo "Error: start.sh not found in barcodeAPI directory!"
          exit 1
        fi

    # This step used to clean up scripts created directly in the PWD.
    # Since scripts are now in ./scripts/infra and executed from there,
    # this step primarily serves as a note or could clean other temp files if any were created by workflow steps.
    - name: Clean up temporary workflow-generated scripts (if any)
      run: |
        echo "Cleaning up temporary workflow scripts from PWD (if any existed)..."
        # Example: echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f script1.sh script2.sh
        echo "Note: Main operational scripts are located in ./scripts/infra/ and are part of the repository."

    # Starts/restarts essential services. Nginx is restarted.
    # PM2 applications and Docker containers are typically started by their respective setup scripts.
    # This step ensures Nginx is running with the new configuration.
    - name: Start or restart essential services
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S systemctl restart nginx || echo "Nginx restart failed. Check Nginx configuration and status."
        # PM2 applications should be started/reloaded by the configure-pm2.sh script.
        # Docker services should be started by the setup-docker-env.sh script (via docker compose up).

    # Restarts the Docker daemon. This can be disruptive and might be redundant
    # if Docker was already started correctly by install-dependencies.sh or setup-docker-env.sh.
    # Consider if this is truly needed or if a 'docker ps' check is sufficient.
    - name: Restart Docker service
      run: |
        echo "Checking Docker status before attempting restart..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S systemctl status docker || echo "Docker was not running or status could not be determined before restart."
        echo "Restarting Docker service..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S systemctl restart docker
        echo "Waiting for Docker to restart..."
        sleep 15 # Increased wait time for Docker daemon to initialize.
        echo "Verifying Docker daemon is responsive..."
        docker ps # Check if Docker daemon is responsive after restart.

    # Cleans up the temporary global environment variables file.
    # This is crucial for security as the file may contain sensitive data.
    - name: Securely clean up global environment variables file
      if: always() # Ensures this step runs even if previous steps fail.
      run: |
        echo "Cleaning up /tmp/env_vars..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f /tmp/env_vars

    # Prints final environment information for debugging and record-keeping.
    - name: Print final environment information
      run: |
        echo "Infrastructure setup workflow completed for environment: ${{ env.ENVIRONMENT }}"
        echo "Domain configured (if applicable): ${{ env.DOMAIN_NAME }}"