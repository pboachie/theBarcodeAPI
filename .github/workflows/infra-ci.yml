name: theBarcodeApi Infrastructure Setup

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT }}
  SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  API_SECRET_KEY: ${{ secrets.API_SECRET_KEY }}
  API_MASTER_KEY: ${{ secrets.API_MASTER_KEY }}
  API_VERSION: ${{ vars.API_VERSION }}

jobs:
  infra-ci-job:
    runs-on: self-hosted

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Setup Initial Directories
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p "/opt/thebarcodeapi/${ENVIRONMENT}/releases/barcodeAPI"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p "/opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p "/opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mkdir -p "/opt/thebarcodeapi/${ENVIRONMENT}/releases/backups"
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R github-runner:github-runner "/opt/thebarcodeapi/${ENVIRONMENT}/releases"

    - name: Configure sudoers
      run: |
        echo "Configuring sudoers..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c 'echo "github-runner ALL=(ALL) NOPASSWD: /usr/bin/pm2, /usr/bin/npm" | sudo tee /etc/sudoers.d/github-runner'
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 0440 /etc/sudoers.d/github-runner

    - name: Create system update script
      run: |
        echo "Creating system update script..."
        cat << 'EOF' > update_system.sh
        #!/bin/bash
        set -e
        echo "Updating system packages..."
        apt-get update
        apt-get upgrade -y
        echo "System update completed."
        EOF
        chmod +x update_system.sh

    - name: Update system
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./update_system.sh
      continue-on-error: true

    - name: Check and install dependencies
      run: |
        echo "Creating dependency installation script..."
        cat << 'EOF' > install_dependencies.sh
        #!/bin/bash
        set -e

        # Function to check if a command exists
        command_exists() {
          command -v "$1" >/dev/null 2>&1
        }

        # Function to install Docker Compose
        install_docker_compose() {
          echo "Installing Docker Compose..."

          # Create plugin directories
          mkdir -p ~/.docker/cli-plugins/
          mkdir -p /usr/local/lib/docker/cli-plugins

          # Download and install Docker Compose binary
          COMPOSE_URL="https://github.com/docker/compose/releases/download/v2.20.3/docker-compose-$(uname -s)-$(uname -m)"
          curl -L "$COMPOSE_URL" -o /usr/local/bin/docker-compose
          chmod +x /usr/local/bin/docker-compose
          ln -sf /usr/local/bin/docker-compose /usr/bin/docker-compose

          # Install as plugin
          curl -L "$COMPOSE_URL" -o ~/.docker/cli-plugins/docker-compose
          chmod +x ~/.docker/cli-plugins/docker-compose
          cp ~/.docker/cli-plugins/docker-compose /usr/local/lib/docker/cli-plugins/docker-compose
        }

        echo "Starting dependency installation check..."

        # Install Nginx if not present
        if ! command_exists nginx; then
          echo "Installing Nginx..."
          apt-get install -y nginx
        else
          echo "Nginx already installed"
        fi

        # Install Node.js if not present
        if ! command_exists node; then
          echo "Installing Node.js 20.x..."
          curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
          apt-get install -y nodejs
        else
          echo "Node.js already installed"
        fi

        # Install PM2 if not present
        if ! command_exists pm2; then
          echo "Installing PM2..."
          npm install -g pm2
        else
          echo "PM2 already installed"
        fi

        # Install Docker if not present
        if ! command_exists docker; then
          echo "Installing Docker..."
          # Install prerequisites
          apt-get update
          apt-get install -y ca-certificates curl gnupg lsb-release

          # Add Docker's official GPG key
          mkdir -p /etc/apt/keyrings
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg

          # Add Docker repository
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | \
            tee /etc/apt/sources.list.d/docker.list > /dev/null

          # Install Docker Engine
          apt-get update
          apt-get install -y docker-ce docker-ce-cli containerd.io

          # Start and enable Docker service
          systemctl start docker
          systemctl enable docker

          # Add github-runner to docker group
          usermod -aG docker github-runner
        else
          echo "Docker already installed"
        fi

        # Install Docker Compose if not present
        if ! (docker compose version || docker-compose --version) &> /dev/null; then
          install_docker_compose
        else
          echo "Docker Compose already installed"
        fi

        # Verify all installations
        echo "Verifying installations..."

        declare -A commands=(
          ["Nginx"]="nginx -v"
          ["Node.js"]="node -v"
          ["PM2"]="pm2 --version"
          ["Docker"]="docker --version"
          ["Docker Compose"]="docker compose version || docker-compose --version"
        )

        for name in "${!commands[@]}"; do
          echo "Checking $name..."
          if ! eval "${commands[$name]}" &> /dev/null; then
            echo "Error: $name installation failed"
            exit 1
          fi
        done

        # Ensure docker group membership
        if ! groups github-runner | grep -q docker; then
          echo "Adding github-runner to docker group..."
          usermod -aG docker github-runner
          echo "Note: You may need to log out and back in for docker group changes to take effect"
        fi

        echo "All installations verified successfully"

        # Display all versions
        echo "Installed versions:"
        nginx -v
        node -v
        pm2 --version
        docker --version
        docker compose version || docker-compose --version
        EOF
        chmod +x install_dependencies.sh
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./install_dependencies.sh

    - name: Configure Nginx
      run: |
        echo "Creating Nginx configuration script..."
        cat << 'EOF' > configure_nginx.sh
        #!/bin/bash
        set -e

        # Read environment variables from file
        source /tmp/env_vars

        # Configure Nginx
        echo "Configuring Nginx..."
        cat > /etc/nginx/sites-available/thebarcodeapi << EOL
        server {
            listen 80;
            listen [::]:80;
            server_name 192.168.1.112;
            server_tokens off;

            # Frontend Next.js application
            location / {
                proxy_pass http://localhost:3000;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host \$host;
                proxy_cache_bypass \$http_upgrade;
            }

            # Backend API
            location /api {
                proxy_pass http://localhost:8000;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host \$host;
                proxy_cache_bypass \$http_upgrade;
            }

            # Security headers
            add_header X-Frame-Options "SAMEORIGIN" always;
            add_header X-XSS-Protection "1; mode=block" always;
            add_header X-Content-Type-Options "nosniff" always;
            add_header Referrer-Policy "no-referrer-when-downgrade" always;
            add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

            # Logging
            access_log /var/log/nginx/thebarcodeapi.access.log;
            error_log /var/log/nginx/thebarcodeapi.error.log warn;
        }
        EOL

        ln -sf /etc/nginx/sites-available/thebarcodeapi /etc/nginx/sites-enabled/
        nginx -t
        EOF
        chmod +x configure_nginx.sh

        # Create environment variables file
        echo "DOMAIN_NAME=${{ env.DOMAIN_NAME }}" > /tmp/env_vars
        echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" >> /tmp/env_vars

        # Run configuration script
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./configure_nginx.sh

        # Clean up
        rm -f /tmp/env_vars

    - name: Configure PM2 for Frontend
      run: |
        echo "Creating PM2 configuration script..."
        cat << 'EOF' > configure_pm2.sh
        #!/bin/bash
        set -e

        # Read environment variables from file
        source /tmp/env_vars

        # Create required directories with proper permissions
        echo "Creating required directories..."
        sudo mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/current
        sudo chown -R github-runner:github-runner /opt/thebarcodeapi

        # Configure PM2
        echo "Configuring PM2..."
        cat > /opt/thebarcodeapi/${ENVIRONMENT}/ecosystem.config.js << EEOF
        module.exports = {
          apps: [{
            name: 'thebarcodeapi-frontend-${ENVIRONMENT}',
            script: 'npm',
            args: 'start',
            env: {
              NODE_ENV: '${ENVIRONMENT}',
              ENVIRONMENT: '${ENVIRONMENT}',
              PORT: 3000
            },
            cwd: '/opt/thebarcodeapi/${ENVIRONMENT}/current',
            instances: 2,
            exec_mode: 'cluster',
            autorestart: true,
            watch: false,
            max_memory_restart: '1G',
            wait_ready: true,
            listen_timeout: 30000,
            kill_timeout: 5000,
            exp_backoff_restart_delay: 1000,
            restart_delay: 5000,
            max_restarts: 5,
            error_file: '/opt/thebarcodeapi/${ENVIRONMENT}/logs/err.log',
            out_file: '/opt/thebarcodeapi/${ENVIRONMENT}/logs/out.log',
            merge_logs: true,
            min_uptime: '30s'
            }]
          };
          EEOF

          # Create log directory
          sudo mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/logs
          sudo chown -R github-runner:github-runner /opt/thebarcodeapi/${ENVIRONMENT}/logs

          # Stop and remove existing PM2 processes
          echo "Managing PM2 process..."
          PM2_HOME="/home/github-runner/.pm2" pm2 delete "thebarcodeapi-frontend-${ENVIRONMENT}" || true

          # Wait for processes to fully stop
          sleep 10

          # Start PM2 with the new configuration
          cd "/opt/thebarcodeapi/${ENVIRONMENT}/current" || exit 1
          PM2_HOME="/home/github-runner/.pm2" pm2 start /opt/thebarcodeapi/${ENVIRONMENT}/ecosystem.config.js
          PM2_HOME="/home/github-runner/.pm2" pm2 save

          # Set final permissions
          sudo chown -R www-data:www-data /opt/thebarcodeapi
          sudo chmod -R 755 /opt/thebarcodeapi

          # Show logs to help with debugging
          sleep 5
          echo "Recent logs:"
          tail -n 50 /opt/thebarcodeapi/${ENVIRONMENT}/logs/err.log
          EOF

          chmod +x configure_pm2.sh

          # Create environment variables file
          echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" > /tmp/env_vars

          # Run configuration script
          echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./configure_pm2.sh

          # Clean up
          rm -f /tmp/env_vars

    - name: Configure Backend Docker Environment
      run: |
        echo "Creating Docker environment setup script..."
        cat << 'EOF' > setup_docker.sh
        #!/bin/bash
        set -e

        # Read environment variables from file
        source /tmp/env_vars

        # Create necessary directories
        mkdir -p /opt/thebarcodeapi/barcodeAPI
        mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases
        mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/data
        mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/backups
        mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis
        mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres

        # Navigate to backend directory
        cd /opt/thebarcodeapi/barcodeAPI

        # Copy backend files
        cp -R /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI/barcodeAPI/* .

        # Create .env file before Docker build
        cat > .env << EOL
        API_VERSION=${API_VERSION}
        SECRET_KEY=${API_SECRET_KEY}
        MASTER_API_KEY=${API_MASTER_KEY}
        ALGORITHM=HS256
        ACCESS_TOKEN_EXPIRE_MINUTES=30
        REDIS_URL=redis://redis:6379
        DATABASE_URL=postgresql+asyncpg://barcodeboachiefamily:${DB_PASSWORD}@db/barcode_api
        EOL

        # Create docker-compose.yml
        cat > docker-compose.yml << EOL
        version: '3.8'

        services:
          api:
            build:
              context: .
              dockerfile: Dockerfile
              args:
                - PYTHON_ENV=production
            ports:
              - "8000:8000"
            depends_on:
              db:
                condition: service_healthy
              redis:
                condition: service_healthy
            env_file:
              - .env
            volumes:
              - ./app:/app/app
              - ./alembic:/app/alembic
              # Don't mount .env as it's copied during build
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
              interval: 15s
              timeout: 10s
              retries: 3
              start_period: 30s
            restart: unless-stopped
            logging:
              driver: "json-file"
              options:
                max-size: "10m"
                max-file: "3"

          redis:
            image: redislabs/rejson:latest
            ports:
              - "6379:6379"
            volumes:
              - /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis:/data
            healthcheck:
              test: ["CMD", "redis-cli", "ping"]
              interval: 5s
              timeout: 30s
              retries: 50
            restart: unless-stopped

          db:
            image: postgres:13
            volumes:
              - /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/postgres:/var/lib/postgresql/data
              - ./init-db.sh:/docker-entrypoint-initdb.d/init-db.sh
            environment:
              - POSTGRES_USER=postgres
              - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
              - BARCODE_DB_USER=barcodeboachiefamily
              - BARCODE_DB_PASSWORD=${DB_PASSWORD}
              - BARCODE_DB_NAME=barcode_api
            healthcheck:
              test: ["CMD-SHELL", "pg_isready -U barcodeboachiefamily -d barcode_api"]
              interval: 5s
              timeout: 5s
              retries: 5
            restart: unless-stopped
            logging:
              driver: "json-file"
              options:
                max-size: "10m"
                max-file: "3"

        networks:
          default:
            name: barcodeapi_network
        EOL

        # Create backup script
        cat > /opt/thebarcodeapi/barcodeAPI/backup.sh << EOL
        #!/bin/bash
        TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
        BACKUP_DIR="/opt/thebarcodeapi/${ENVIRONMENT}/releases/backups"

        # Backup PostgreSQL
        docker compose exec db pg_dump -U barcodeboachiefamily barcode_api > "\$BACKUP_DIR/db_backup_\$TIMESTAMP.sql"

        # Backup Redis
        docker compose exec redis redis-cli SAVE
        cp /opt/thebarcodeapi/${ENVIRONMENT}/releases/data/redis/dump.rdb "\$BACKUP_DIR/redis_backup_\$TIMESTAMP.rdb"

        # Clean old backups (keep last 7 days)
        find \$BACKUP_DIR -name "db_backup_*" -mtime +7 -delete
        find \$BACKUP_DIR -name "redis_backup_*" -mtime +7 -delete
        EOL
        chmod +x /opt/thebarcodeapi/barcodeAPI/backup.sh

        # Set up cron job for backups
        (crontab -l 2>/dev/null; echo "0 0 * * * /opt/thebarcodeapi/barcodeAPI/backup.sh") | crontab -

        # Ensure start.sh is executable
        chmod +x start.sh

        # Create wait-for-it script for startup coordination
        cat > wait-for-it.sh << 'EOL'
        #!/bin/bash
        # wait-for-it.sh script to check service availability

        host="$1"
        port="$2"
        shift 2
        cmd="$@"

        until nc -z "$host" "$port"; do
          echo "Waiting for $host:$port..."
          sleep 1
        done

        echo "$host:$port is available"
        exec $cmd
        EOL
        chmod +x wait-for-it.sh

        # Set permissions
        chown -R www-data:www-data /opt/thebarcodeapi
        chown -R github-runner:github-runner /opt/thebarcodeapi/barcodeAPI
        chmod -R 755 /opt/thebarcodeapi/barcodeAPI

        echo "Docker environment setup completed"
        EOF
        chmod +x setup_docker.sh

        # Create environment variables file
        echo "API_SECRET_KEY=${{ env.API_SECRET_KEY }}" > /tmp/env_vars
        echo "API_MASTER_KEY=${{ env.API_MASTER_KEY }}" >> /tmp/env_vars
        echo "DB_PASSWORD=${{ env.DB_PASSWORD }}" >> /tmp/env_vars
        echo "POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}" >> /tmp/env_vars
        echo "API_VERSION=${{ env.API_VERSION }}" >> /tmp/env_vars

        # Run setup script
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./setup_docker.sh

        # Clean up
        rm -f /tmp/env_vars

    - name: Fix Permissions
      run: |
        echo "Fixing permissions..."
        cat << 'EOF' > fix_permissions.sh
        #!/bin/bash
        set -e

        # Create required directories if they don't exist
        mkdir -p /opt/thebarcodeapi/barcodeAPI
        mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/data
        mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}/releases/backups

        # Set ownership
        chown -R www-data:www-data /opt/thebarcodeapi

        # Set directory permissions
        find /opt/thebarcodeapi -type d -exec chmod 755 {} \;

        # Set file permissions
        find /opt/thebarcodeapi -type f -exec chmod 644 {} \;

        # Make scripts executable
        find /opt/thebarcodeapi -name "*.sh" -exec chmod +x {} \;

        # Ensure special permissions for sensitive files
        if [ -f "/opt/thebarcodeapi/barcodeAPI/.env" ]; then
          chmod 600 /opt/thebarcodeapi/barcodeAPI/.env
        fi

        # Set proper permissions for Docker socket
        if [ -S /var/run/docker.sock ]; then
          chmod 666 /var/run/docker.sock
        fi

        # set theBarcodeAPI directory permissions
        chown -R github-runner:github-runner /opt/thebarcodeapi/barcodeAPI

        # set ownership for backup folder
        chown www-data:www-data /opt/thebarcodeapi/${ENVIRONMENT}/releases/backups
        echo "Permissions fixed successfully"
        EOF

        chmod +x fix_permissions.sh
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./fix_permissions.sh

    - name: Configure Backup Coordination
      run: |
        echo "Setting up backup coordination..."
        # First create script locally
        cat << 'EOF' > pre-backup-check.sh
        #!/bin/bash
        set -e

        # Check if deployment is in progress
        if [ -f "/opt/thebarcodeapi/deployment.lock" ]; then
          echo "Deployment in progress, skipping backup"
          exit 0
        fi

        # Proceed with backup
        /opt/thebarcodeapi/barcodeAPI/backup.sh
        EOF
        chmod +x pre-backup-check.sh

        # Move to destination with sudo
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mv pre-backup-check.sh /opt/thebarcodeapi/barcodeAPI/pre-backup-check.sh
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown www-data:www-data /opt/thebarcodeapi/barcodeAPI/pre-backup-check.sh
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 755 /opt/thebarcodeapi/barcodeAPI/pre-backup-check.sh

        # Update cron job with sudo
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c '(crontab -l 2>/dev/null | grep -v "backup.sh" | grep -v "pre-backup-check.sh") | crontab -'
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c '(crontab -l 2>/dev/null; echo "0 0 * * * /opt/thebarcodeapi/barcodeAPI/pre-backup-check.sh") | crontab -'

    - name: Add Cleanup Routine
      run: |
        # First create the script in current directory
        cat << 'EOF' > cleanup.sh
        #!/bin/bash
        set -e

        # Clean old frontend releases
        find /opt/thebarcodeapi/${ENVIRONMENT}/releases -maxdepth 1 -type d -mtime +30 -exec rm -rf {} \;

        # Clean old backups (keep last 30 days)
        find /opt/thebarcodeapi/${ENVIRONMENT}/releases/backups -maxdepth 1 -type d -mtime +30 -exec rm -rf {} \;

        # Clean Docker
        docker system prune -f --filter "until=168h"
        EOF
        chmod +x cleanup.sh

        # Then move it to the target location with sudo
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S mv cleanup.sh /opt/thebarcodeapi/cleanup.sh
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown www-data:www-data /opt/thebarcodeapi/cleanup.sh
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 755 /opt/thebarcodeapi/cleanup.sh

        # Add weekly cleanup to cron with sudo
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c '(crontab -l 2>/dev/null; echo "0 0 * * 0 /opt/thebarcodeapi/cleanup.sh") | crontab -'

    - name: Error Check
      run: |
        # Check if critical files exist
        for file in "/opt/thebarcodeapi/barcodeAPI/backup.sh" "/opt/thebarcodeapi/barcodeAPI/pre-backup-check.sh" "/opt/thebarcodeapi/cleanup.sh"; do
          if [ ! -x "$file" ]; then
            echo "Error: $file is not executable or doesn't exist"
            exit 1
          fi
        done

    - name: Verify Setup
      run: |
        echo "Verifying setup..."
        cat << 'EOF' > verify_setup.sh
        #!/bin/bash
        set -e

        # Check directory structure
        echo "Checking directory structure..."
        for dir in barcodeAPI data backups; do
          if [ ! -d "/opt/thebarcodeapi/$dir" ]; then
            echo "Error: Directory /opt/thebarcodeapi/$dir not found"
            exit 1
          fi
        done

        echo "Checking wait-for-it script..."
        if [ ! -x "/opt/thebarcodeapi/barcodeAPI/wait-for-it.sh" ]; then
          echo "Error: wait-for-it.sh not executable"
          exit 1
        fi

        # Check script permissions
        echo "Checking script permissions..."
        for script in backup.sh pre-backup-check.sh; do
          if [ ! -x "/opt/thebarcodeapi/barcodeAPI/$script" ]; then
            echo "Error: $script not executable"
            exit 1
          fi
        done

        # Check cron job
        echo "Checking cron job..."
        if ! crontab -l | grep -q "pre-backup-check.sh"; then
          echo "Error: Backup cron job not found"
          exit 1
        fi

        # Check ownership
        echo "Checking ownership..."
        if [ "$(stat -c %U:%G /opt/thebarcodeapi)" != "www-data:www-data" ]; then
          echo "Error: Incorrect ownership on /opt/thebarcodeapi"
          exit 1
        fi

        echo "Setup verified successfully"
        EOF
        chmod +x verify_setup.sh
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./verify_setup.sh

    - name: Verify Repository Structure
      run: |
        if [ ! -d "barcodeAPI" ]; then
          echo "Error: barcodeAPI directory not found!"
          exit 1
        fi

        if [ ! -f "barcodeAPI/requirements.txt" ]; then
          echo "Error: requirements.txt not found in barcodeAPI directory!"
          exit 1
        fi

        if [ ! -f "barcodeAPI/start.sh" ]; then
          echo "Error: start.sh not found in barcodeAPI directory!"
          exit 1
        fi

    - name: Clean up scripts
      run: |
        echo "Cleaning up..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f update_system.sh install_dependencies.sh configure_nginx.sh configure_pm2.sh setup_docker.sh verify_setup.sh setup_backup.sh fix_permissions.sh

    - name: Start Services
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S systemctl restart nginx

    - name: Restart Docker
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S systemctl restart docker
        # Wait for Docker to be ready
        sleep 5

    - name: Print Environment Info (for debugging)
      run: |
        echo "Deployed to ${{ env.ENVIRONMENT }} environment"
        echo "Domain: ${{ env.DOMAIN_NAME }}"