name: theBarcodeApi Infrastructure Setup

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  DOMAIN_NAME: ${{ secrets.DOMAIN_NAME }}
  ENVIRONMENT: ${{ vars.ENVIRONMENT }}
  SUDO_PASSWORD: ${{ secrets.SUDO_PASSWORD }}
  DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  API_SECRET_KEY: ${{ secrets.API_SECRET_KEY }}
  API_MASTER_KEY: ${{ secrets.API_MASTER_KEY }}
  API_VERSION: ${{ vars.API_VERSION }}

jobs:
  infra-ci-job:
    runs-on: self-hosted

    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Configure sudoers
      run: |
        echo "Configuring sudoers..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S bash -c 'echo "github-runner ALL=(ALL) NOPASSWD: /usr/bin/pm2, /usr/bin/npm" | sudo tee /etc/sudoers.d/github-runner'
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod 0440 /etc/sudoers.d/github-runner

    - name: Create system update script
      run: |
        echo "Creating system update script..."
        cat << 'EOF' > update_system.sh
        #!/bin/bash
        set -e
        echo "Updating system packages..."
        apt-get update
        apt-get upgrade -y
        echo "System update completed."
        EOF
        chmod +x update_system.sh

    - name: Update system
      run: echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./update_system.sh
      continue-on-error: true

    - name: Check and install dependencies
      run: |
        echo "Creating dependency installation script..."
        cat << 'EOF' > install_dependencies.sh
        #!/bin/bash
        set -e

        # Function to check if a command exists
        command_exists() {
          command -v "$1" >/dev/null 2>&1
        }

        # Install Nginx if not present
        if ! command_exists nginx; then
          echo "Installing Nginx..."
          apt-get install -y nginx
        else
          echo "Nginx already installed"
        fi

        # Install Node.js if not present
        if ! command_exists node; then
          echo "Installing Node.js 20.x..."
          curl -fsSL https://deb.nodesource.com/setup_20.x | bash -
          apt-get install -y nodejs
        else
          echo "Node.js already installed"
        fi

        # Install PM2 if not present
        if ! command_exists pm2; then
          echo "Installing PM2..."
          npm install -g pm2
        else
          echo "PM2 already installed"
        fi

        # Install Docker if not present
        if ! command_exists docker; then
          echo "Installing Docker..."
          apt-get install -y ca-certificates curl gnupg
          mkdir -p /etc/apt/keyrings
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
          echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
          apt-get update
          apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin

          # Add github-runner to docker group
          usermod -aG docker github-runner

          # Start and enable Docker service
          systemctl start docker
          systemctl enable docker
        else
          echo "Docker already installed"
        fi

        # Verify installations
        echo "Verifying installations..."
        nginx -v
        node -v
        pm2 --version
        docker --version
        docker compose version
        EOF
        chmod +x install_dependencies.sh
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./install_dependencies.sh

    - name: Configure Nginx
      run: |
        echo "Creating Nginx configuration script..."
        cat << 'EOF' > configure_nginx.sh
        #!/bin/bash
        set -e

        # Read environment variables from file
        source /tmp/env_vars

        # Configure Nginx
        echo "Configuring Nginx..."
        cat > /etc/nginx/sites-available/thebarcodeapi << EOL
        server {
            listen 80;
            listen [::]:80;
            server_name 192.168.1.112;
            server_tokens off;

            # Frontend Next.js application
            location / {
                proxy_pass http://localhost:3000;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host \$host;
                proxy_cache_bypass \$http_upgrade;
            }

            # Backend API
            location /api {
                proxy_pass http://localhost:8000;
                proxy_http_version 1.1;
                proxy_set_header Upgrade \$http_upgrade;
                proxy_set_header Connection 'upgrade';
                proxy_set_header Host \$host;
                proxy_cache_bypass \$http_upgrade;
            }

            # Security headers
            add_header X-Frame-Options "SAMEORIGIN" always;
            add_header X-XSS-Protection "1; mode=block" always;
            add_header X-Content-Type-Options "nosniff" always;
            add_header Referrer-Policy "no-referrer-when-downgrade" always;
            add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

            # Logging
            access_log /var/log/nginx/thebarcodeapi.access.log;
            error_log /var/log/nginx/thebarcodeapi.error.log warn;
        }
        EOL

        ln -sf /etc/nginx/sites-available/thebarcodeapi /etc/nginx/sites-enabled/
        nginx -t
        EOF
        chmod +x configure_nginx.sh

        # Create environment variables file
        echo "DOMAIN_NAME=${{ env.DOMAIN_NAME }}" > /tmp/env_vars
        echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" >> /tmp/env_vars

        # Run configuration script
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./configure_nginx.sh

        # Clean up
        rm -f /tmp/env_vars

    - name: Configure PM2 for Frontend
      run: |
        echo "Creating PM2 configuration script..."
        cat << 'EOF' > configure_pm2.sh
        #!/bin/bash
        set -e

        # Read environment variables from file
        source /tmp/env_vars

        # Configure PM2
        echo "Configuring PM2..."
        mkdir -p /opt/thebarcodeapi/${ENVIRONMENT}
        cat > /opt/thebarcodeapi/${ENVIRONMENT}/ecosystem.config.js << EOL
        module.exports = {
          apps: [{
            name: 'thebarcodeapi-frontend-${ENVIRONMENT}',
            script: 'npm',
            args: 'start',
            cwd: '/opt/thebarcodeapi/${ENVIRONMENT}/current',
            instances: 'max',
            autorestart: true,
            watch: false,
            max_memory_restart: '1G',
            env: {
              NODE_ENV: 'production',
              ENVIRONMENT: '${ENVIRONMENT}'
            }
          }]
        };
        EOL

        # Set permissions
        chown -R www-data:www-data /opt/thebarcodeapi
        chmod -R 755 /opt/thebarcodeapi
        EOF
        chmod +x configure_pm2.sh

        # Create environment variables file
        echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" > /tmp/env_vars

        # Run configuration script
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./configure_pm2.sh

        # Clean up
        rm -f /tmp/env_vars

    - name: Configure Backend Docker Environment
      run: |
        echo "Creating Docker environment setup script..."
        cat << 'EOF' > setup_docker.sh
        #!/bin/bash
        set -e

        # Read environment variables from file
        source /tmp/env_vars

        # Create necessary directories
        mkdir -p /opt/thebarcodeapi/barcodeAPI
        mkdir -p /opt/thebarcodeapi/data/postgres
        mkdir -p /opt/thebarcodeapi/data/redis
        mkdir -p /opt/thebarcodeapi/backups

        # Navigate to backend directory
        cd /opt/thebarcodeapi/barcodeAPI

        # Copy backend files
        cp -R /home/github-runner/actions-runner/_work/theBarcodeAPI/theBarcodeAPI/barcodeAPI/* .

        # Create .env file before Docker build
        cat > .env << EOL
        API_VERSION=${API_VERSION}
        SECRET_KEY=${API_SECRET_KEY}
        MASTER_API_KEY=${API_MASTER_KEY}
        ALGORITHM=HS256
        ACCESS_TOKEN_EXPIRE_MINUTES=30
        REDIS_URL=redis://redis:6379
        DATABASE_URL=postgresql+asyncpg://barcodeboachiefamily:${DB_PASSWORD}@db/barcode_api
        PYTHONDONTWRITEBYTECODE=1
        PYTHONUNBUFFERED=1
        EOL

        # Create docker-compose.yml
        cat > docker-compose.yml << EOL
        version: '3.8'

        services:
          api:
            build:
              context: .
              dockerfile: Dockerfile
              args:
                - PYTHON_ENV=production
            ports:
              - "8000:8000"
            depends_on:
              db:
                condition: service_healthy
              redis:
                condition: service_healthy
            env_file:
              - .env
            volumes:
              - ./app:/app/app
              - ./alembic:/app/alembic
              # Don't mount .env as it's copied during build
            healthcheck:
              test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
              interval: 15s
              timeout: 10s
              retries: 3
              start_period: 30s
            restart: unless-stopped
            logging:
              driver: "json-file"
              options:
                max-size: "10m"
                max-file: "3"

          redis:
            image: redislabs/rejson:latest
            ports:
              - "6379:6379"
            volumes:
              - /opt/thebarcodeapi/data/redis:/data
            healthcheck:
              test: ["CMD", "redis-cli", "ping"]
              interval: 5s
              timeout: 30s
              retries: 50
            restart: unless-stopped

          db:
            image: postgres:13
            volumes:
              - /opt/thebarcodeapi/data/postgres:/var/lib/postgresql/data
              - ./init-db.sh:/docker-entrypoint-initdb.d/init-db.sh
            environment:
              - POSTGRES_USER=postgres
              - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
              - BARCODE_DB_USER=barcodeboachiefamily
              - BARCODE_DB_PASSWORD=${DB_PASSWORD}
              - BARCODE_DB_NAME=barcode_api
            healthcheck:
              test: ["CMD-SHELL", "pg_isready -U barcodeboachiefamily -d barcode_api"]
              interval: 5s
              timeout: 5s
              retries: 5
            restart: unless-stopped
            logging:
              driver: "json-file"
              options:
                max-size: "10m"
                max-file: "3"

        networks:
          default:
            name: barcodeapi_network
        EOL

        # Create backup script
        cat > /opt/thebarcodeapi/barcodeAPI/backup.sh << EOL
        #!/bin/bash
        TIMESTAMP=\$(date +%Y%m%d_%H%M%S)
        BACKUP_DIR="/opt/thebarcodeapi/backups"

        # Backup PostgreSQL
        docker compose exec db pg_dump -U barcodeboachiefamily barcode_api > "\$BACKUP_DIR/db_backup_\$TIMESTAMP.sql"

        # Backup Redis
        docker compose exec redis redis-cli SAVE
        cp /opt/thebarcodeapi/data/redis/dump.rdb "\$BACKUP_DIR/redis_backup_\$TIMESTAMP.rdb"

        # Clean old backups (keep last 7 days)
        find \$BACKUP_DIR -name "db_backup_*" -mtime +7 -delete
        find \$BACKUP_DIR -name "redis_backup_*" -mtime +7 -delete
        EOL
        chmod +x /opt/thebarcodeapi/barcodeAPI/backup.sh

        # Set up cron job for backups
        (crontab -l 2>/dev/null; echo "0 0 * * * /opt/thebarcodeapi/barcodeAPI/backup.sh") | crontab -

        # Ensure start.sh is executable
        chmod +x start.sh

        # Create wait-for-it script for startup coordination
        cat > wait-for-it.sh << 'EOL'
        #!/bin/bash
        # wait-for-it.sh script to check service availability

        host="$1"
        port="$2"
        shift 2
        cmd="$@"

        until nc -z "$host" "$port"; do
          echo "Waiting for $host:$port..."
          sleep 1
        done

        echo "$host:$port is available"
        exec $cmd
        EOL
        chmod +x wait-for-it.sh

        # Set permissions
        chown -R www-data:www-data /opt/thebarcodeapi
        chmod -R 755 /opt/thebarcodeapi/barcodeAPI

        echo "Docker environment setup completed"
        EOF
        chmod +x setup_docker.sh

        # Create environment variables file
        echo "API_SECRET_KEY=${{ env.API_SECRET_KEY }}" > /tmp/env_vars
        echo "API_MASTER_KEY=${{ env.API_MASTER_KEY }}" >> /tmp/env_vars
        echo "DB_PASSWORD=${{ env.DB_PASSWORD }}" >> /tmp/env_vars
        echo "POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}" >> /tmp/env_vars
        echo "API_VERSION=${{ env.API_VERSION }}" >> /tmp/env_vars

        # Run setup script
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./setup_docker.sh

        # Clean up
        rm -f /tmp/env_vars

    - name: Configure Backup Coordination
      run: |
        cat << 'EOF' > /opt/thebarcodeapi/barcodeAPI/pre-backup-check.sh
        #!/bin/bash

        # Check if deployment is in progress
        if [ -f "/opt/thebarcodeapi/deployment.lock" ]; then
          echo "Deployment in progress, skipping backup"
          exit 0
        fi

        # Proceed with backup
        /opt/thebarcodeapi/barcodeAPI/backup.sh
        EOF
        chmod +x /opt/thebarcodeapi/barcodeAPI/pre-backup-check.sh

        # Update cron job to use pre-backup check
        (crontab -l 2>/dev/null | grep -v "backup.sh") | crontab -
        (crontab -l 2>/dev/null; echo "0 0 * * * /opt/thebarcodeapi/barcodeAPI/pre-backup-check.sh") | crontab -

    - name: Add Cleanup Routine
      run: |
        cat << 'EOF' > /opt/thebarcodeapi/cleanup.sh
        #!/bin/bash

        # Clean old frontend releases
        find /opt/thebarcodeapi/${ENVIRONMENT}/releases -maxdepth 1 -type d -mtime +30 -exec rm -rf {} \;

        # Clean old backups (keep last 30 days)
        find /opt/thebarcodeapi/backups -maxdepth 1 -type d -mtime +30 -exec rm -rf {} \;

        # Clean Docker
        docker system prune -f --filter "until=168h"
        EOF
        chmod +x /opt/thebarcodeapi/cleanup.sh

        # Add weekly cleanup to cron
        (crontab -l 2>/dev/null; echo "0 0 * * 0 /opt/thebarcodeapi/cleanup.sh") | crontab -

    - name: Fix Permissions
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chown -R www-data:www-data /opt/thebarcodeapi/data
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S chmod -R 755 /opt/thebarcodeapi/data

    - name: Verify setup
      run: |
        echo "Creating verification script..."
        cat << 'EOF' > verify_setup.sh
        #!/bin/bash
        set -e

        echo "Verifying installations and configurations..."

        # Check installed services
        echo "Checking service versions..."
        nginx -v
        node -v
        pm2 --version
        docker --version
        docker compose version

        # Check configurations
        echo "Checking Nginx configuration..."
        nginx -t

        echo "Checking directory structure..."
        ls -la /opt/thebarcodeapi/barcodeAPI
        ls -la /opt/thebarcodeapi/${ENVIRONMENT}

        echo "Checking Docker network..."
        docker network ls | grep barcodeapi_network || echo "Network not yet created"

        echo "Verification completed"
        EOF
        chmod +x verify_setup.sh
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S ./verify_setup.sh

    - name: Verify Repository Structure
      run: |
        if [ ! -d "barcodeAPI" ]; then
          echo "Error: barcodeAPI directory not found!"
          exit 1
        fi

        if [ ! -f "barcodeAPI/requirements.txt" ]; then
          echo "Error: requirements.txt not found in barcodeAPI directory!"
          exit 1
        fi

        if [ ! -f "barcodeAPI/start.sh" ]; then
          echo "Error: start.sh not found in barcodeAPI directory!"
          exit 1
        fi

    - name: Clean up scripts
      run: |
        echo "Cleaning up..."
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S rm -f update_system.sh install_dependencies.sh configure_nginx.sh configure_pm2.sh setup_docker.sh verify_setup.sh

    - name: Start Services
      run: |
        echo "${{ env.SUDO_PASSWORD }}" | sudo -S systemctl restart nginx

    - name: Print Environment Info (for debugging)
      run: |
        echo "Deployed to ${{ env.ENVIRONMENT }} environment"
        echo "Domain: ${{ env.DOMAIN_NAME }}"