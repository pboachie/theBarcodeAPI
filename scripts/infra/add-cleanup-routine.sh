# ---
# Purpose:
#   Creates a cleanup script (/opt/thebarcodeapi/cleanup.sh) and sets up a cron job to run it weekly.
#   The cleanup script is responsible for:
#     - Removing old frontend releases.
#     - Deleting old database and Redis backups.
#     - Pruning unused Docker data (images, containers, networks, build cache).
#
# Environment Variables (expected from /tmp/env_vars or direct pass for SUDO_PASSWORD):
#   - SUDO_PASSWORD: Password for sudo execution, used for file operations and crontab management.
#   - ENVIRONMENT: The deployment environment (e.g., staging, production). Used within the
#                  generated cleanup.sh script to define paths for cleanup.
#
# Outputs:
#   - Creates /opt/thebarcodeapi/cleanup.sh with the cleanup logic.
#   - Adds a cron job to execute this script weekly.
#   - Logs the setup process.
# ---
#!/bin/bash
set -e

echo "Starting setup of cleanup routine..."

# Attempt to source environment variables if /tmp/env_vars exists
if [ -f /tmp/env_vars ]; then
  source /tmp/env_vars
  echo "Sourced environment variables from /tmp/env_vars."
else
  echo "Warning: /tmp/env_vars not found. Relying on ENVIRONMENT and SUDO_PASSWORD being directly available."
fi

# Ensure critical variables are set
if [ -z "$SUDO_PASSWORD" ]; then
  echo "Error: SUDO_PASSWORD environment variable is not set."
  exit 1
fi
if [ -z "$ENVIRONMENT" ]; then
  echo "Error: ENVIRONMENT environment variable is not set (needed for the cleanup script content)."
  exit 1
fi

echo "Setting up cleanup script and cron job for environment: ${ENVIRONMENT}"

# Content for the cleanup.sh script that will be placed on the server
# Note: The ENVIRONMENT variable will be embedded into this script.
CLEANUP_SCRIPT_CONTENT="#!/bin/bash
set -e
# ---
# This script is auto-generated by scripts/infra/add-cleanup-routine.sh
# Purpose: Performs routine cleanup of old deployment artifacts and Docker data.
# Environment: Embedded value for ENVIRONMENT = ${ENVIRONMENT}
# ---

echo \"Starting cleanup routine at \$(date) for environment: ${ENVIRONMENT}\"

# Clean old frontend releases
# Path for frontend releases, specific to the environment
FRONTEND_RELEASES_PATH=\\\"/opt/thebarcodeapi/${ENVIRONMENT}/releases\\\"
echo \\\"Cleaning old frontend releases from \${FRONTEND_RELEASES_PATH} (older than 30 days)...\\\"
if [ -d \\\"\$FRONTEND_RELEASES_PATH\\\" ]; then
  # Find directories named 'release-*', modified more than 30 days ago, and remove them
  find \\\"\$FRONTEND_RELEASES_PATH\\\" -maxdepth 1 -type d -name \\\"release-*\\\" -mtime +30 -exec echo \\\"Removing old release: {}\\\" \\\; -exec rm -rf {} \\\;
else
  echo \\\"Frontend releases path \${FRONTEND_RELEASES_PATH} not found. Skipping cleanup.\\\"
fi

# Clean old backups
# Path for backups, specific to the environment
BACKUPS_PATH=\\\"/opt/thebarcodeapi/${ENVIRONMENT}/backups\\\"
echo \\\"Cleaning old backups from \${BACKUPS_PATH} (older than 30 days)...\\\"
if [ -d \\\"\$BACKUPS_PATH\\\" ]; then
  # Find files matching backup patterns, modified more than 30 days ago, and remove them
  find \\\"\$BACKUPS_PATH\\\" -maxdepth 1 -type f \\\( -name \\\"db_backup_*.sql\\\" -o -name \\\"redis_backup_*.rdb\\\" -o -name \\\"backup_*.tar.gz\\\" \\\) -mtime +30 -exec echo \\\"Removing old backup file: {}\\\" \\\; -exec rm -f {} \\\;
else
  echo \\\"Backups path \${BACKUPS_PATH} not found. Skipping cleanup.\\\"
fi

# Clean Docker system: remove unused containers, networks, images, and build cache
echo \\\"Pruning Docker system (older than 1 week)...\\\"
docker system prune -a -f --filter \\\"until=168h\\\" # -a prunes all unused images, not just dangling ones

echo \\\"Cleanup routine finished at \$(date).\\\"
" # End of CLEANUP_SCRIPT_CONTENT

# Create cleanup.sh script locally first to ensure content is correct
TEMP_CLEANUP_SCRIPT="./cleanup_temp.sh"
echo "Creating temporary cleanup script at ${TEMP_CLEANUP_SCRIPT}..."
# Use printf to avoid issues with backslashes and quotes in CLEANUP_SCRIPT_CONTENT
printf '%s\n' "$CLEANUP_SCRIPT_CONTENT" > "$TEMP_CLEANUP_SCRIPT"
chmod +x "$TEMP_CLEANUP_SCRIPT"

# Define the target path for the cleanup script on the server
TARGET_CLEANUP_SCRIPT="/opt/thebarcodeapi/cleanup.sh"
echo "Moving temporary cleanup script to ${TARGET_CLEANUP_SCRIPT} using sudo..."
echo "${SUDO_PASSWORD}" | sudo -S mv "$TEMP_CLEANUP_SCRIPT" "$TARGET_CLEANUP_SCRIPT"
echo "$SUDO_PASSWORD" | sudo -S chown $USER:$USER "$TARGET_CLEANUP_SCRIPT"
echo "${SUDO_PASSWORD}" | sudo -S chmod 755 "$TARGET_CLEANUP_SCRIPT"
echo "Cleanup script deployed to ${TARGET_CLEANUP_SCRIPT}."

# Add weekly cleanup cron job
echo "Updating cron job for cleanup routine..."
CRON_CLEANUP_PATH="$TARGET_CLEANUP_SCRIPT" # Use the target path variable
CRON_CLEANUP_SCHEDULE="0 0 * * 0" # Runs weekly on Sunday at midnight

# Safely remove any existing cron job for this script path to avoid duplicates, then add the new one
# This uses `grep -v -F` to ensure exact path matching and avoid removing similar paths.
echo "${SUDO_PASSWORD}" | sudo -S bash -c "(crontab -l 2>/dev/null | grep -v -F '${CRON_CLEANUP_PATH}' ; echo '${CRON_CLEANUP_SCHEDULE} ${CRON_CLEANUP_PATH}') | crontab -"
echo "Cron job for cleanup updated/added. Current crontab (for the user executing this, likely root via sudo):"
echo "${SUDO_PASSWORD}" | sudo -S crontab -l

echo "Cleanup routine setup complete."
