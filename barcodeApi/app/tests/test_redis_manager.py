import asyncio
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime
import pytz

# Adjust imports based on your project structure if RedisManager or UserData are elsewhere
from app.redis_manager import RedisManager
from app.schemas import UserData
from app.config import settings # Assuming settings are used for rate limits

# Mock the IDGenerator if it's used in UserData creation within the tested method or fallbacks
@patch('app.utils.IDGenerator.generate_id', return_value="test_user_id")
@pytest.mark.asyncio
async def test_process_increment_usage_argument_passing(mock_generate_id):
    # 1. Setup Mocks
    mock_redis_client = AsyncMock()
    manager = RedisManager(redis=mock_redis_client)
    manager.increment_usage_sha = "test_script_sha" # Simulate loaded script SHA

    # Mock pipeline and evalsha
    # This mock_pipe will be used by _process_increment_usage
    mock_pipe_main_flow = AsyncMock()
    mock_pipe_main_flow.evalsha.return_value = [ # Simulate Lua script return
        b'10', # requests_today
        b'4990', # remaining_requests
        datetime.now(pytz.utc).isoformat().encode('utf-8'), # last_request
        datetime.now(pytz.utc).isoformat().encode('utf-8')  # last_reset
    ]
    mock_pipe_main_flow.execute = AsyncMock(return_value=[mock_pipe_main_flow.evalsha.return_value])

    # This mock_pipe is for the pipeline call inside create_default_user_data (fallback)
    mock_pipe_fallback_flow = AsyncMock()
    mock_pipe_fallback_flow.hset.return_value = None # Simulate HSET result
    mock_pipe_fallback_flow.expire.return_value = None # Simulate EXPIRE result
    mock_pipe_fallback_flow.execute = AsyncMock(return_value=[True, True, True, True]) # Simulate execution results

    # Configure manager.redis.pipeline() to return the appropriate pipe mock
    # based on how many times it has been called.
    # First call in _process_increment_usage, second in create_default_user_data (if fallback occurs)
    async_cm_mock_main = AsyncMock()
    async_cm_mock_main.__aenter__.return_value = mock_pipe_main_flow

    async_cm_mock_fallback = AsyncMock()
    async_cm_mock_fallback.__aenter__.return_value = mock_pipe_fallback_flow

    # manager.redis is mock_redis_client
    # The pipeline() method is called twice if the fallback in _process_increment_usage is hit.
    # Once directly in _process_increment_usage, and once in create_default_user_data.
    # For this test, the fallback IS hit because the evalsha result processing has a bug
    # (now fixed in redis_manager.py, but the test was written to expect this path due to the bug)
    # or if evalsha returns an error.
    # Let's simplify: the first call to pipeline() in the test is for _process_increment_usage.
    # If that fails and goes to create_default_user_data, another pipeline() is called.
    # The test needs to mock both calls if the fallback is expected.
    # The provided evalsha result *should* be successful now after the decode fix.
    # So, create_default_user_data path might not be hit for the *success* case.
    # However, the AttributeError: __aenter__ was specifically from create_default_user_data.
    # This implies the fallback was being hit. Let's ensure the mock handles multiple calls.

    # We will make manager.redis.pipeline (which is mock_redis_client.pipeline)
    # return a context manager that provides the correct pipe.
    # The first time it's called (in _process_increment_usage), it returns async_cm_mock_main.
    # The second time (in create_default_user_data), it returns async_cm_mock_fallback.
    mock_redis_client.pipeline.side_effect = [async_cm_mock_main, async_cm_mock_fallback, async_cm_mock_fallback, async_cm_mock_fallback]


    # Mock settings
    original_rate_limit_settings = settings.RateLimit
    settings.RateLimit = MagicMock()
    settings.RateLimit.get_limit = MagicMock(return_value=5000)

    # Mock datetime to control current_time
    fixed_datetime = datetime(2023, 1, 1, 12, 0, 0, tzinfo=pytz.utc)

    # Patch datetime directly in the redis_manager module
    with patch('app.redis_manager.datetime') as mock_dt:
        mock_dt.now.return_value = fixed_datetime
        # Ensure fromisoformat keeps working for other parts of the code if necessary
        mock_dt.fromisoformat.side_effect = lambda iso_str: datetime.fromisoformat(iso_str)

        # 2. Prepare Test Data
        user_id = "test_user_123"
        ip_address = "192.168.1.1"
        items_to_process = [((user_id, ip_address), "internal_id_1")]
        pending_results_futures = {"internal_id_1": asyncio.Future()}

        # Expected key generated by _get_key
        expected_key = f"user_data:{user_id}"
        expected_current_time_iso = fixed_datetime.isoformat()
        expected_rate_limit_str = "5000"

        # 3. Call the Method
        # The first pipe instance from the side_effect is used here via the async with in _process_increment_usage
        await manager._process_increment_usage(items_to_process, mock_pipe_main_flow, pending_results_futures)
        await pending_results_futures["internal_id_1"] # Wait for the future

        # 4. Assertions
        mock_pipe_main_flow.evalsha.assert_called_once_with(
            manager.increment_usage_sha,
            1,
            expected_key,
            str(user_id),
            str(ip_address),
            expected_rate_limit_str,
            expected_current_time_iso
        )

        assert pending_results_futures["internal_id_1"].done()
        result_data = pending_results_futures["internal_id_1"].result()
        assert isinstance(result_data, UserData)
        assert result_data.id == user_id
        assert result_data.ip_address == ip_address

        # Test with user_id = None
        mock_pipe_main_flow.reset_mock() # Reset the first pipe mock
        # If create_default_user_data is called, the second pipe mock (mock_pipe_fallback_flow) will be used.
        # We also need to reset the pipeline side_effect if we expect specific calls.
        # For the no_user case, _process_increment_usage will be called again, so pipeline() will be called again.
        mock_redis_client.pipeline.side_effect = [async_cm_mock_main, async_cm_mock_fallback, async_cm_mock_fallback, async_cm_mock_fallback]


        pending_results_futures_no_user = {"internal_id_2": asyncio.Future()}
        items_no_user = [((None, ip_address), "internal_id_2")]
        # Assuming _get_key compresses IP for the key when user_id is None
        # This part might need adjustment if _get_key has more complex logic for None user_id
        with patch.object(manager, '_get_key', return_value=f"ip:{ip_address}") as mock_get_key:
            # The second call to _process_increment_usage will use the first pipe from the *new* side_effect list
            await manager._process_increment_usage(items_no_user, mock_pipe_main_flow, pending_results_futures_no_user)
            await pending_results_futures_no_user["internal_id_2"]

            mock_get_key.assert_called_with(None, ip_address)
            expected_key_no_user = f"ip:{ip_address}"

            mock_pipe_main_flow.evalsha.assert_called_once_with(
                manager.increment_usage_sha,
                1,
                expected_key_no_user,
                str(ip_address),
                str(ip_address),
                expected_rate_limit_str,
                expected_current_time_iso
            )
        assert pending_results_futures_no_user["internal_id_2"].done()
        result_data_no_user = pending_results_futures_no_user["internal_id_2"].result()
        assert isinstance(result_data_no_user, UserData)
        assert result_data_no_user.id == "test_user_id"
        assert result_data_no_user.ip_address == ip_address

    # Restore original settings
    settings.RateLimit = original_rate_limit_settings
